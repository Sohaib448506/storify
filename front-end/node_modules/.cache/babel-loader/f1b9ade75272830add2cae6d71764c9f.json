{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nexports.default = parse;\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\n * Parses structured e-mail addresses from an address field\n *\n * Example:\n *\n *    \"Name <address@domain>\"\n *\n * will be converted to\n *\n *     [{name: \"Name\", address: \"address@domain\"}]\n *\n * @param {String} str Address field\n * @return {Array} An array of address objects\n */\n\n\nfunction parse(str) {\n  var tokenizer = new Tokenizer(str);\n  var tokens = tokenizer.tokenize();\n  var addresses = [];\n  var address = [];\n  var parsedAddresses = [];\n  tokens.forEach(function (token) {\n    if (token.type === 'operator' && (token.value === ',' || token.value === ';')) {\n      if (address.length) {\n        addresses.push(address);\n      }\n\n      address = [];\n    } else {\n      address.push(token);\n    }\n  });\n\n  if (address.length) {\n    addresses.push(address);\n  }\n\n  addresses.forEach(function (address) {\n    address = _handleAddress(address);\n\n    if (address.length) {\n      parsedAddresses = parsedAddresses.concat(address);\n    }\n  });\n  return parsedAddresses;\n}\n\n;\n/**\n * Converts tokens for a single address into an address object\n *\n * @param {Array} tokens Tokens object\n * @return {Object} Address object\n */\n\nfunction _handleAddress(tokens) {\n  var isGroup = false;\n  var state = 'text';\n  var address = void 0;\n  var addresses = [];\n  var data = {\n    address: [],\n    comment: [],\n    group: [],\n    text: [] // Filter out <addresses>, (comments) and regular text\n\n  };\n\n  for (var i = 0, len = tokens.length; i < len; i++) {\n    var token = tokens[i];\n\n    if (token.type === 'operator') {\n      switch (token.value) {\n        case '<':\n          state = 'address';\n          break;\n\n        case '(':\n          state = 'comment';\n          break;\n\n        case ':':\n          state = 'group';\n          isGroup = true;\n          break;\n\n        default:\n          state = 'text';\n      }\n    } else {\n      if (token.value) {\n        data[state].push(token.value);\n      }\n    }\n  } // If there is no text but a comment, replace the two\n\n\n  if (!data.text.length && data.comment.length) {\n    data.text = data.comment;\n    data.comment = [];\n  }\n\n  if (isGroup) {\n    // http://tools.ietf.org/html/rfc2822#appendix-A.1.3\n    data.text = data.text.join(' ');\n    addresses.push({\n      name: data.text || address && address.name,\n      group: data.group.length ? parse(data.group.join(',')) : []\n    });\n  } else {\n    // If no address was found, try to detect one from regular text\n    if (!data.address.length && data.text.length) {\n      for (var _i = data.text.length - 1; _i >= 0; _i--) {\n        if (data.text[_i].match(/^[^@\\s]+@[^@\\s]+$/)) {\n          data.address = data.text.splice(_i, 1);\n          break;\n        }\n      }\n\n      var _regexHandler = function _regexHandler(address) {\n        if (!data.address.length) {\n          data.address = [address.trim()];\n          return ' ';\n        } else {\n          return address;\n        }\n      }; // still no address\n\n\n      if (!data.address.length) {\n        for (var _i2 = data.text.length - 1; _i2 >= 0; _i2--) {\n          data.text[_i2] = data.text[_i2].replace(/\\s*\\b[^@\\s]+@[^@\\s]+\\b\\s*/, _regexHandler).trim();\n\n          if (data.address.length) {\n            break;\n          }\n        }\n      }\n    } // If there's still is no text but a comment exixts, replace the two\n\n\n    if (!data.text.length && data.comment.length) {\n      data.text = data.comment;\n      data.comment = [];\n    } // Keep only the first address occurence, push others to regular text\n\n\n    if (data.address.length > 1) {\n      data.text = data.text.concat(data.address.splice(1));\n    } // Join values with spaces\n\n\n    data.text = data.text.join(' ');\n    data.address = data.address.join(' ');\n\n    if (!data.address && isGroup) {\n      return [];\n    } else {\n      address = {\n        address: data.address || data.text || '',\n        name: data.text || data.address || ''\n      };\n\n      if (address.address === address.name) {\n        if ((address.address || '').match(/@/)) {\n          address.name = '';\n        } else {\n          address.address = '';\n        }\n      }\n\n      addresses.push(address);\n    }\n  }\n\n  return addresses;\n}\n\n;\n/*\n * Operator tokens and which tokens are expected to end the sequence\n */\n\nvar OPERATORS = {\n  '\"': '\"',\n  '(': ')',\n  '<': '>',\n  ',': '',\n  // Groups are ended by semicolons\n  ':': ';',\n  // Semicolons are not a legal delimiter per the RFC2822 grammar other\n  // than for terminating a group, but they are also not valid for any\n  // other use in this context.  Given that some mail clients have\n  // historically allowed the semicolon as a delimiter equivalent to the\n  // comma in their UI, it makes sense to treat them the same as a comma\n  // when used outside of a group.\n  ';': ''\n  /**\n   * Creates a Tokenizer object for tokenizing address field strings\n   *\n   * @constructor\n   * @param {String} str Address field string\n   */\n\n};\n\nvar Tokenizer = function () {\n  function Tokenizer(str) {\n    _classCallCheck(this, Tokenizer);\n\n    this.str = (str || '').toString();\n    this.operatorCurrent = '';\n    this.operatorExpecting = '';\n    this.node = null;\n    this.escaped = false;\n    this.list = [];\n  }\n  /**\n   * Tokenizes the original input string\n   *\n   * @return {Array} An array of operator|text tokens\n   */\n\n\n  _createClass(Tokenizer, [{\n    key: 'tokenize',\n    value: function tokenize() {\n      var chr = void 0;\n      var list = [];\n\n      for (var i = 0, len = this.str.length; i < len; i++) {\n        chr = this.str.charAt(i);\n        this.checkChar(chr);\n      }\n\n      this.list.forEach(function (node) {\n        node.value = (node.value || '').toString().trim();\n\n        if (node.value) {\n          list.push(node);\n        }\n      });\n      return list;\n    }\n    /**\n     * Checks if a character is an operator or text and acts accordingly\n     *\n     * @param {String} chr Character from the address field\n     */\n\n  }, {\n    key: 'checkChar',\n    value: function checkChar(chr) {\n      if ((chr in OPERATORS || chr === '\\\\') && this.escaped) {\n        this.escaped = false;\n      } else if (this.operatorExpecting && chr === this.operatorExpecting) {\n        this.node = {\n          type: 'operator',\n          value: chr\n        };\n        this.list.push(this.node);\n        this.node = null;\n        this.operatorExpecting = '';\n        this.escaped = false;\n        return;\n      } else if (!this.operatorExpecting && chr in OPERATORS) {\n        this.node = {\n          type: 'operator',\n          value: chr\n        };\n        this.list.push(this.node);\n        this.node = null;\n        this.operatorExpecting = OPERATORS[chr];\n        this.escaped = false;\n        return;\n      }\n\n      if (!this.escaped && chr === '\\\\') {\n        this.escaped = true;\n        return;\n      }\n\n      if (!this.node) {\n        this.node = {\n          type: 'text',\n          value: ''\n        };\n        this.list.push(this.node);\n      }\n\n      if (this.escaped && chr !== '\\\\') {\n        this.node.value += '\\\\';\n      }\n\n      this.node.value += chr;\n      this.escaped = false;\n    }\n  }]);\n\n  return Tokenizer;\n}();","map":{"version":3,"mappings":"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","names":["parse","str","tokenizer","Tokenizer","tokens","tokenize","addresses","address","parsedAddresses","forEach","token","type","value","length","push","_handleAddress","concat","isGroup","state","data","comment","group","text","i","len","join","name","match","splice","_regexHandler","trim","replace","OPERATORS","_classCallCheck","toString","operatorCurrent","operatorExpecting","node","escaped","list","chr","charAt","checkChar"],"sources":["../src/addressparser.js"],"sourcesContent":["/**\n * Parses structured e-mail addresses from an address field\n *\n * Example:\n *\n *    \"Name <address@domain>\"\n *\n * will be converted to\n *\n *     [{name: \"Name\", address: \"address@domain\"}]\n *\n * @param {String} str Address field\n * @return {Array} An array of address objects\n */\nexport default function parse (str) {\n  const tokenizer = new Tokenizer(str)\n  const tokens = tokenizer.tokenize()\n\n  const addresses = []\n  let address = []\n  let parsedAddresses = []\n\n  tokens.forEach(function (token) {\n    if (token.type === 'operator' && (token.value === ',' || token.value === ';')) {\n      if (address.length) {\n        addresses.push(address)\n      }\n      address = []\n    } else {\n      address.push(token)\n    }\n  })\n\n  if (address.length) {\n    addresses.push(address)\n  }\n\n  addresses.forEach(function (address) {\n    address = _handleAddress(address)\n    if (address.length) {\n      parsedAddresses = parsedAddresses.concat(address)\n    }\n  })\n\n  return parsedAddresses\n};\n\n/**\n * Converts tokens for a single address into an address object\n *\n * @param {Array} tokens Tokens object\n * @return {Object} Address object\n */\nfunction _handleAddress (tokens) {\n  let isGroup = false\n  let state = 'text'\n  let address\n  const addresses = []\n  const data = {\n    address: [],\n    comment: [],\n    group: [],\n    text: []\n  }\n\n  // Filter out <addresses>, (comments) and regular text\n  for (let i = 0, len = tokens.length; i < len; i++) {\n    const token = tokens[i]\n\n    if (token.type === 'operator') {\n      switch (token.value) {\n        case '<':\n          state = 'address'\n          break\n        case '(':\n          state = 'comment'\n          break\n        case ':':\n          state = 'group'\n          isGroup = true\n          break\n        default:\n          state = 'text'\n      }\n    } else {\n      if (token.value) {\n        data[state].push(token.value)\n      }\n    }\n  }\n\n  // If there is no text but a comment, replace the two\n  if (!data.text.length && data.comment.length) {\n    data.text = data.comment\n    data.comment = []\n  }\n\n  if (isGroup) {\n    // http://tools.ietf.org/html/rfc2822#appendix-A.1.3\n    data.text = data.text.join(' ')\n    addresses.push({\n      name: data.text || (address && address.name),\n      group: data.group.length ? parse(data.group.join(',')) : []\n    })\n  } else {\n    // If no address was found, try to detect one from regular text\n    if (!data.address.length && data.text.length) {\n      for (let i = data.text.length - 1; i >= 0; i--) {\n        if (data.text[i].match(/^[^@\\s]+@[^@\\s]+$/)) {\n          data.address = data.text.splice(i, 1)\n          break\n        }\n      }\n\n      var _regexHandler = function (address) {\n        if (!data.address.length) {\n          data.address = [address.trim()]\n          return ' '\n        } else {\n          return address\n        }\n      }\n\n      // still no address\n      if (!data.address.length) {\n        for (let i = data.text.length - 1; i >= 0; i--) {\n          data.text[i] = data.text[i].replace(/\\s*\\b[^@\\s]+@[^@\\s]+\\b\\s*/, _regexHandler).trim()\n          if (data.address.length) {\n            break\n          }\n        }\n      }\n    }\n\n    // If there's still is no text but a comment exixts, replace the two\n    if (!data.text.length && data.comment.length) {\n      data.text = data.comment\n      data.comment = []\n    }\n\n    // Keep only the first address occurence, push others to regular text\n    if (data.address.length > 1) {\n      data.text = data.text.concat(data.address.splice(1))\n    }\n\n    // Join values with spaces\n    data.text = data.text.join(' ')\n    data.address = data.address.join(' ')\n\n    if (!data.address && isGroup) {\n      return []\n    } else {\n      address = {\n        address: data.address || data.text || '',\n        name: data.text || data.address || ''\n      }\n\n      if (address.address === address.name) {\n        if ((address.address || '').match(/@/)) {\n          address.name = ''\n        } else {\n          address.address = ''\n        }\n      }\n\n      addresses.push(address)\n    }\n  }\n\n  return addresses\n};\n\n/*\n * Operator tokens and which tokens are expected to end the sequence\n */\nconst OPERATORS = {\n  '\"': '\"',\n  '(': ')',\n  '<': '>',\n  ',': '',\n  // Groups are ended by semicolons\n  ':': ';',\n  // Semicolons are not a legal delimiter per the RFC2822 grammar other\n  // than for terminating a group, but they are also not valid for any\n  // other use in this context.  Given that some mail clients have\n  // historically allowed the semicolon as a delimiter equivalent to the\n  // comma in their UI, it makes sense to treat them the same as a comma\n  // when used outside of a group.\n  ';': ''\n}\n\n/**\n * Creates a Tokenizer object for tokenizing address field strings\n *\n * @constructor\n * @param {String} str Address field string\n */\nclass Tokenizer {\n  constructor (str) {\n    this.str = (str || '').toString()\n    this.operatorCurrent = ''\n    this.operatorExpecting = ''\n    this.node = null\n    this.escaped = false\n    this.list = []\n  }\n\n  /**\n   * Tokenizes the original input string\n   *\n   * @return {Array} An array of operator|text tokens\n   */\n  tokenize () {\n    let chr\n    let list = []\n    for (var i = 0, len = this.str.length; i < len; i++) {\n      chr = this.str.charAt(i)\n      this.checkChar(chr)\n    }\n\n    this.list.forEach(function (node) {\n      node.value = (node.value || '').toString().trim()\n      if (node.value) {\n        list.push(node)\n      }\n    })\n\n    return list\n  }\n\n  /**\n   * Checks if a character is an operator or text and acts accordingly\n   *\n   * @param {String} chr Character from the address field\n   */\n  checkChar (chr) {\n    if ((chr in OPERATORS || chr === '\\\\') && this.escaped) {\n      this.escaped = false\n    } else if (this.operatorExpecting && chr === this.operatorExpecting) {\n      this.node = {\n        type: 'operator',\n        value: chr\n      }\n      this.list.push(this.node)\n      this.node = null\n      this.operatorExpecting = ''\n      this.escaped = false\n      return\n    } else if (!this.operatorExpecting && chr in OPERATORS) {\n      this.node = {\n        type: 'operator',\n        value: chr\n      }\n      this.list.push(this.node)\n      this.node = null\n      this.operatorExpecting = OPERATORS[chr]\n      this.escaped = false\n      return\n    }\n\n    if (!this.escaped && chr === '\\\\') {\n      this.escaped = true\n      return\n    }\n\n    if (!this.node) {\n      this.node = {\n        type: 'text',\n        value: ''\n      }\n      this.list.push(this.node)\n    }\n\n    if (this.escaped && chr !== '\\\\') {\n      this.node.value += '\\\\'\n    }\n\n    this.node.value += chr\n    this.escaped = false\n  }\n}\n"]},"metadata":{},"sourceType":"script"}