{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MimeNode = exports.NodeCounter = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nexports.default = parse;\n\nvar _ramda = require('ramda');\n\nvar _timezones = require('./timezones');\n\nvar _timezones2 = _interopRequireDefault(_timezones);\n\nvar _emailjsMimeCodec = require('emailjs-mime-codec');\n\nvar _textEncoding = require('text-encoding');\n\nvar _emailjsAddressparser = require('emailjs-addressparser');\n\nvar _emailjsAddressparser2 = _interopRequireDefault(_emailjsAddressparser);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/*\n * Counts MIME nodes to prevent memory exhaustion attacks (CWE-400)\n * see: https://snyk.io/vuln/npm:emailjs-mime-parser:20180625\n */\n\n\nvar MAXIMUM_NUMBER_OF_MIME_NODES = 999;\n\nvar NodeCounter = exports.NodeCounter = function () {\n  function NodeCounter() {\n    _classCallCheck(this, NodeCounter);\n\n    this.count = 0;\n  }\n\n  _createClass(NodeCounter, [{\n    key: 'bump',\n    value: function bump() {\n      if (++this.count > MAXIMUM_NUMBER_OF_MIME_NODES) {\n        throw new Error('Maximum number of MIME nodes exceeded!');\n      }\n    }\n  }]);\n\n  return NodeCounter;\n}();\n\nfunction parse(chunk) {\n  var root = new MimeNode(new NodeCounter());\n  var lines = ((typeof chunk === 'undefined' ? 'undefined' : _typeof(chunk)) === 'object' ? String.fromCharCode.apply(null, chunk) : chunk).split(/\\r?\\n/g);\n  lines.forEach(function (line) {\n    return root.writeLine(line);\n  });\n  root.finalize();\n  return root;\n}\n\nvar MimeNode = exports.MimeNode = function () {\n  function MimeNode() {\n    var nodeCounter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new NodeCounter();\n\n    _classCallCheck(this, MimeNode);\n\n    this.nodeCounter = nodeCounter;\n    this.nodeCounter.bump();\n    this.header = []; // An array of unfolded header lines\n\n    this.headers = {}; // An object that holds header key=value pairs\n\n    this.bodystructure = '';\n    this.childNodes = []; // If this is a multipart or message/rfc822 mime part, the value will be converted to array and hold all child nodes for this node\n\n    this.raw = ''; // Stores the raw content of this node\n\n    this._state = 'HEADER'; // Current state, always starts out with HEADER\n\n    this._bodyBuffer = ''; // Body buffer\n\n    this._lineCount = 0; // Line counter bor the body part\n\n    this._currentChild = false; // Active child node (if available)\n\n    this._lineRemainder = ''; // Remainder string when dealing with base64 and qp values\n\n    this._isMultipart = false; // Indicates if this is a multipart node\n\n    this._multipartBoundary = false; // Stores boundary value for current multipart node\n\n    this._isRfc822 = false; // Indicates if this is a message/rfc822 node\n  }\n\n  _createClass(MimeNode, [{\n    key: 'writeLine',\n    value: function writeLine(line) {\n      this.raw += (this.raw ? '\\n' : '') + line;\n\n      if (this._state === 'HEADER') {\n        this._processHeaderLine(line);\n      } else if (this._state === 'BODY') {\n        this._processBodyLine(line);\n      }\n    }\n  }, {\n    key: 'finalize',\n    value: function finalize() {\n      var _this = this;\n\n      if (this._isRfc822) {\n        this._currentChild.finalize();\n      } else {\n        this._emitBody();\n      }\n\n      this.bodystructure = this.childNodes.reduce(function (agg, child) {\n        return agg + '--' + _this._multipartBoundary + '\\n' + child.bodystructure;\n      }, this.header.join('\\n') + '\\n\\n') + (this._multipartBoundary ? '--' + this._multipartBoundary + '--\\n' : '');\n    }\n  }, {\n    key: '_decodeBodyBuffer',\n    value: function _decodeBodyBuffer() {\n      switch (this.contentTransferEncoding.value) {\n        case 'base64':\n          this._bodyBuffer = (0, _emailjsMimeCodec.base64Decode)(this._bodyBuffer, this.charset);\n          break;\n\n        case 'quoted-printable':\n          {\n            this._bodyBuffer = this._bodyBuffer.replace(/=(\\r?\\n|$)/g, '').replace(/=([a-f0-9]{2})/ig, function (m, code) {\n              return String.fromCharCode(parseInt(code, 16));\n            });\n            break;\n          }\n      }\n    }\n    /**\n     * Processes a line in the HEADER state. It the line is empty, change state to BODY\n     *\n     * @param {String} line Entire input line as 'binary' string\n     */\n\n  }, {\n    key: '_processHeaderLine',\n    value: function _processHeaderLine(line) {\n      if (!line) {\n        this._parseHeaders();\n\n        this.bodystructure += this.header.join('\\n') + '\\n\\n';\n        this._state = 'BODY';\n        return;\n      }\n\n      if (line.match(/^\\s/) && this.header.length) {\n        this.header[this.header.length - 1] += '\\n' + line;\n      } else {\n        this.header.push(line);\n      }\n    }\n    /**\n     * Joins folded header lines and calls Content-Type and Transfer-Encoding processors\n     */\n\n  }, {\n    key: '_parseHeaders',\n    value: function _parseHeaders() {\n      for (var hasBinary = false, i = 0, len = this.header.length; i < len; i++) {\n        var value = this.header[i].split(':');\n        var key = (value.shift() || '').trim().toLowerCase();\n        value = (value.join(':') || '').replace(/\\n/g, '').trim();\n\n        if (value.match(/[\\u0080-\\uFFFF]/)) {\n          if (!this.charset) {\n            hasBinary = true;\n          } // use default charset at first and if the actual charset is resolved, the conversion is re-run\n\n\n          value = (0, _emailjsMimeCodec.decode)((0, _emailjsMimeCodec.convert)(str2arr(value), this.charset || 'iso-8859-1'));\n        }\n\n        this.headers[key] = (this.headers[key] || []).concat([this._parseHeaderValue(key, value)]);\n\n        if (!this.charset && key === 'content-type') {\n          this.charset = this.headers[key][this.headers[key].length - 1].params.charset;\n        }\n\n        if (hasBinary && this.charset) {\n          // reset values and start over once charset has been resolved and 8bit content has been found\n          hasBinary = false;\n          this.headers = {};\n          i = -1; // next iteration has i == 0\n        }\n      }\n\n      this.fetchContentType();\n\n      this._processContentTransferEncoding();\n    }\n    /**\n     * Parses single header value\n     * @param {String} key Header key\n     * @param {String} value Value for the key\n     * @return {Object} parsed header\n     */\n\n  }, {\n    key: '_parseHeaderValue',\n    value: function _parseHeaderValue(key, value) {\n      var parsedValue = void 0;\n      var isAddress = false;\n\n      switch (key) {\n        case 'content-type':\n        case 'content-transfer-encoding':\n        case 'content-disposition':\n        case 'dkim-signature':\n          parsedValue = (0, _emailjsMimeCodec.parseHeaderValue)(value);\n          break;\n\n        case 'from':\n        case 'sender':\n        case 'to':\n        case 'reply-to':\n        case 'cc':\n        case 'bcc':\n        case 'abuse-reports-to':\n        case 'errors-to':\n        case 'return-path':\n        case 'delivered-to':\n          isAddress = true;\n          parsedValue = {\n            value: [].concat((0, _emailjsAddressparser2.default)(value) || [])\n          };\n          break;\n\n        case 'date':\n          parsedValue = {\n            value: this._parseDate(value)\n          };\n          break;\n\n        default:\n          parsedValue = {\n            value: value\n          };\n      }\n\n      parsedValue.initial = value;\n\n      this._decodeHeaderCharset(parsedValue, {\n        isAddress: isAddress\n      });\n\n      return parsedValue;\n    }\n    /**\n     * Checks if a date string can be parsed. Falls back replacing timezone\n     * abbrevations with timezone values. Bogus timezones default to UTC.\n     *\n     * @param {String} str Date header\n     * @returns {String} UTC date string if parsing succeeded, otherwise returns input value\n     */\n\n  }, {\n    key: '_parseDate',\n    value: function _parseDate() {\n      var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      var date = new Date(str.trim().replace(/\\b[a-z]+$/i, function (tz) {\n        return _timezones2.default[tz.toUpperCase()] || '+0000';\n      }));\n      return date.toString() !== 'Invalid Date' ? date.toUTCString().replace(/GMT/, '+0000') : str;\n    }\n  }, {\n    key: '_decodeHeaderCharset',\n    value: function _decodeHeaderCharset(parsed) {\n      var _this2 = this;\n\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          isAddress = _ref.isAddress; // decode default value\n\n\n      if (typeof parsed.value === 'string') {\n        parsed.value = (0, _emailjsMimeCodec.mimeWordsDecode)(parsed.value);\n      } // decode possible params\n\n\n      Object.keys(parsed.params || {}).forEach(function (key) {\n        if (typeof parsed.params[key] === 'string') {\n          parsed.params[key] = (0, _emailjsMimeCodec.mimeWordsDecode)(parsed.params[key]);\n        }\n      }); // decode addresses\n\n      if (isAddress && Array.isArray(parsed.value)) {\n        parsed.value.forEach(function (addr) {\n          if (addr.name) {\n            addr.name = (0, _emailjsMimeCodec.mimeWordsDecode)(addr.name);\n\n            if (Array.isArray(addr.group)) {\n              _this2._decodeHeaderCharset({\n                value: addr.group\n              }, {\n                isAddress: true\n              });\n            }\n          }\n        });\n      }\n\n      return parsed;\n    }\n    /**\n     * Parses Content-Type value and selects following actions.\n     */\n\n  }, {\n    key: 'fetchContentType',\n    value: function fetchContentType() {\n      var defaultValue = (0, _emailjsMimeCodec.parseHeaderValue)('text/plain');\n      this.contentType = (0, _ramda.pathOr)(defaultValue, ['headers', 'content-type', '0'])(this);\n      this.contentType.value = (this.contentType.value || '').toLowerCase().trim();\n      this.contentType.type = this.contentType.value.split('/').shift() || 'text';\n\n      if (this.contentType.params && this.contentType.params.charset && !this.charset) {\n        this.charset = this.contentType.params.charset;\n      }\n\n      if (this.contentType.type === 'multipart' && this.contentType.params.boundary) {\n        this.childNodes = [];\n        this._isMultipart = this.contentType.value.split('/').pop() || 'mixed';\n        this._multipartBoundary = this.contentType.params.boundary;\n      }\n      /**\n       * For attachment (inline/regular) if charset is not defined and attachment is non-text/*,\n       * then default charset to binary.\n       * Refer to issue: https://github.com/emailjs/emailjs-mime-parser/issues/18\n       */\n\n\n      var defaultContentDispositionValue = (0, _emailjsMimeCodec.parseHeaderValue)('');\n      var contentDisposition = (0, _ramda.pathOr)(defaultContentDispositionValue, ['headers', 'content-disposition', '0'])(this);\n      var isAttachment = (contentDisposition.value || '').toLowerCase().trim() === 'attachment';\n      var isInlineAttachment = (contentDisposition.value || '').toLowerCase().trim() === 'inline';\n\n      if ((isAttachment || isInlineAttachment) && this.contentType.type !== 'text' && !this.charset) {\n        this.charset = 'binary';\n      }\n\n      if (this.contentType.value === 'message/rfc822' && !isAttachment) {\n        /**\n         * Parse message/rfc822 only if the mime part is not marked with content-disposition: attachment,\n         * otherwise treat it like a regular attachment\n         */\n        this._currentChild = new MimeNode(this.nodeCounter);\n        this.childNodes = [this._currentChild];\n        this._isRfc822 = true;\n      }\n    }\n    /**\n     * Parses Content-Transfer-Encoding value to see if the body needs to be converted\n     * before it can be emitted\n     */\n\n  }, {\n    key: '_processContentTransferEncoding',\n    value: function _processContentTransferEncoding() {\n      var defaultValue = (0, _emailjsMimeCodec.parseHeaderValue)('7bit');\n      this.contentTransferEncoding = (0, _ramda.pathOr)(defaultValue, ['headers', 'content-transfer-encoding', '0'])(this);\n      this.contentTransferEncoding.value = (0, _ramda.pathOr)('', ['contentTransferEncoding', 'value'])(this).toLowerCase().trim();\n    }\n    /**\n     * Processes a line in the BODY state. If this is a multipart or rfc822 node,\n     * passes line value to child nodes.\n     *\n     * @param {String} line Entire input line as 'binary' string\n     */\n\n  }, {\n    key: '_processBodyLine',\n    value: function _processBodyLine(line) {\n      if (this._isMultipart) {\n        if (line === '--' + this._multipartBoundary) {\n          this.bodystructure += line + '\\n';\n\n          if (this._currentChild) {\n            this._currentChild.finalize();\n          }\n\n          this._currentChild = new MimeNode(this.nodeCounter);\n          this.childNodes.push(this._currentChild);\n        } else if (line === '--' + this._multipartBoundary + '--') {\n          this.bodystructure += line + '\\n';\n\n          if (this._currentChild) {\n            this._currentChild.finalize();\n          }\n\n          this._currentChild = false;\n        } else if (this._currentChild) {\n          this._currentChild.writeLine(line);\n        } else {// Ignore multipart preamble\n        }\n      } else if (this._isRfc822) {\n        this._currentChild.writeLine(line);\n      } else {\n        this._lineCount++;\n\n        switch (this.contentTransferEncoding.value) {\n          case 'base64':\n            this._bodyBuffer += line;\n            break;\n\n          case 'quoted-printable':\n            {\n              var curLine = this._lineRemainder + (this._lineCount > 1 ? '\\n' : '') + line;\n              var match = curLine.match(/=[a-f0-9]{0,1}$/i);\n\n              if (match) {\n                this._lineRemainder = match[0];\n                curLine = curLine.substr(0, curLine.length - this._lineRemainder.length);\n              } else {\n                this._lineRemainder = '';\n              }\n\n              this._bodyBuffer += curLine;\n              break;\n            }\n\n          case '7bit':\n          case '8bit':\n          default:\n            this._bodyBuffer += (this._lineCount > 1 ? '\\n' : '') + line;\n            break;\n        }\n      }\n    }\n    /**\n     * Emits a chunk of the body\n    */\n\n  }, {\n    key: '_emitBody',\n    value: function _emitBody() {\n      this._decodeBodyBuffer();\n\n      if (this._isMultipart || !this._bodyBuffer) {\n        return;\n      }\n\n      this._processFlowedText();\n\n      this.content = str2arr(this._bodyBuffer);\n\n      this._processHtmlText();\n\n      this._bodyBuffer = '';\n    }\n  }, {\n    key: '_processFlowedText',\n    value: function _processFlowedText() {\n      var isText = /^text\\/(plain|html)$/i.test(this.contentType.value);\n      var isFlowed = /^flowed$/i.test((0, _ramda.pathOr)('', ['contentType', 'params', 'format'])(this));\n      if (!isText || !isFlowed) return;\n      var delSp = /^yes$/i.test(this.contentType.params.delsp);\n      this._bodyBuffer = this._bodyBuffer.split('\\n').reduce(function (previousValue, currentValue) {\n        // remove soft linebreaks after space symbols.\n        // delsp adds spaces to text to be able to fold it.\n        // these spaces can be removed once the text is unfolded\n        var endsWithSpace = / $/.test(previousValue);\n        var isBoundary = /(^|\\n)-- $/.test(previousValue);\n        return (delSp ? previousValue.replace(/[ ]+$/, '') : previousValue) + (endsWithSpace && !isBoundary ? '' : '\\n') + currentValue;\n      }).replace(/^ /gm, ''); // remove whitespace stuffing http://tools.ietf.org/html/rfc3676#section-4.4\n    }\n  }, {\n    key: '_processHtmlText',\n    value: function _processHtmlText() {\n      var contentDisposition = this.headers['content-disposition'] && this.headers['content-disposition'][0] || (0, _emailjsMimeCodec.parseHeaderValue)('');\n      var isHtml = /^text\\/(plain|html)$/i.test(this.contentType.value);\n      var isAttachment = /^attachment$/i.test(contentDisposition.value);\n\n      if (isHtml && !isAttachment) {\n        if (!this.charset && /^text\\/html$/i.test(this.contentType.value)) {\n          this.charset = this.detectHTMLCharset(this._bodyBuffer);\n        } // decode \"binary\" string to an unicode string\n\n\n        if (!/^utf[-_]?8$/i.test(this.charset)) {\n          this.content = (0, _emailjsMimeCodec.convert)(str2arr(this._bodyBuffer), this.charset || 'iso-8859-1');\n        } else if (this.contentTransferEncoding.value === 'base64') {\n          this.content = utf8Str2arr(this._bodyBuffer);\n        } // override charset for text nodes\n\n\n        this.charset = this.contentType.params.charset = 'utf-8';\n      }\n    }\n    /**\n     * Detect charset from a html file\n     *\n     * @param {String} html Input HTML\n     * @returns {String} Charset if found or undefined\n     */\n\n  }, {\n    key: 'detectHTMLCharset',\n    value: function detectHTMLCharset(html) {\n      var charset = void 0,\n          input = void 0;\n      html = html.replace(/\\r?\\n|\\r/g, ' ');\n      var meta = html.match(/<meta\\s+http-equiv=[\"'\\s]*content-type[^>]*?>/i);\n\n      if (meta) {\n        input = meta[0];\n      }\n\n      if (input) {\n        charset = input.match(/charset\\s?=\\s?([a-zA-Z\\-_:0-9]*);?/);\n\n        if (charset) {\n          charset = (charset[1] || '').trim().toLowerCase();\n        }\n      }\n\n      meta = html.match(/<meta\\s+charset=[\"'\\s]*([^\"'<>/\\s]+)/i);\n\n      if (!charset && meta) {\n        charset = (meta[1] || '').trim().toLowerCase();\n      }\n\n      return charset;\n    }\n  }]);\n\n  return MimeNode;\n}();\n\nvar str2arr = function str2arr(str) {\n  return new Uint8Array(str.split('').map(function (char) {\n    return char.charCodeAt(0);\n  }));\n};\n\nvar utf8Str2arr = function utf8Str2arr(str) {\n  return new _textEncoding.TextEncoder('utf-8').encode(str);\n};","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kBAsBwBA;;AAtBxB;;AACA;;;;AACA;;AACA;;AACA;;;;;;;;;;;;;;;AAEA;;;;;;AAIA,IAAMC,+BAA+B,GAArC;;IACaC,W,WAAAA,W;EACX,uBAAe;IAAAC;;IACb,KAAKC,KAAL,GAAa,CAAb;EACD;;;;2BACO;MACN,IAAI,EAAE,KAAKA,KAAP,GAAeH,4BAAnB,EAAiD;QAC/C,MAAM,IAAII,KAAJ,CAAU,wCAAV,CAAN;MACD;IACF;;;;;;AAGY,SAASL,KAAT,CAAgBM,KAAhB,EAAuB;EACpC,IAAMC,OAAO,IAAIC,QAAJ,CAAa,IAAIN,WAAJ,EAAb,CAAb;EACA,IAAMO,QAAQ,CAAC,QAAOH,KAAP,yCAAOA,KAAP,OAAiB,QAAjB,GAA4BI,OAAOC,YAAPD,CAAoBE,KAApBF,CAA0B,IAA1BA,EAAgCJ,KAAhCI,CAA5B,GAAqEJ,KAAtE,EAA6EO,KAA7E,CAAmF,QAAnF,CAAd;EACAJ,MAAMK,OAANL,CAAc;IAAA,OAAQF,KAAKQ,SAALR,CAAeS,IAAfT,CAAR;EAAd;EACAA,KAAKU,QAALV;EACA,OAAOA,IAAP;AACD;;IAEYC,Q,WAAAA,Q;EACX,oBAA8C;IAAA,IAAjCU,WAAiC,uEAAnB,IAAIhB,WAAJ,EAAmB;;IAAAC;;IAC5C,KAAKe,WAAL,GAAmBA,WAAnB;IACA,KAAKA,WAAL,CAAiBC,IAAjB;IAEA,KAAKC,MAAL,GAAc,EAAd,CAJ4C,CAI3B;;IACjB,KAAKC,OAAL,GAAe,EAAf,CAL4C,CAK1B;;IAClB,KAAKC,aAAL,GAAqB,EAArB;IACA,KAAKC,UAAL,GAAkB,EAAlB,CAP4C,CAOvB;;IACrB,KAAKC,GAAL,GAAW,EAAX,CAR4C,CAQ9B;;IAEd,KAAKC,MAAL,GAAc,QAAd,CAV4C,CAUrB;;IACvB,KAAKC,WAAL,GAAmB,EAAnB,CAX4C,CAWtB;;IACtB,KAAKC,UAAL,GAAkB,CAAlB,CAZ4C,CAYxB;;IACpB,KAAKC,aAAL,GAAqB,KAArB,CAb4C,CAajB;;IAC3B,KAAKC,cAAL,GAAsB,EAAtB,CAd4C,CAcnB;;IACzB,KAAKC,YAAL,GAAoB,KAApB,CAf4C,CAelB;;IAC1B,KAAKC,kBAAL,GAA0B,KAA1B,CAhB4C,CAgBZ;;IAChC,KAAKC,SAAL,GAAiB,KAAjB,CAjB4C,CAiBrB;EACxB;;;;8BAEUhB,MAAM;MACf,KAAKQ,GAAL,IAAY,CAAC,KAAKA,GAAL,GAAW,IAAX,GAAkB,EAAnB,IAAyBR,IAArC;;MAEA,IAAI,KAAKS,MAAL,KAAgB,QAApB,EAA8B;QAC5B,KAAKQ,kBAAL,CAAwBjB,IAAxB;MADF,OAEO,IAAI,KAAKS,MAAL,KAAgB,MAApB,EAA4B;QACjC,KAAKS,gBAAL,CAAsBlB,IAAtB;MACD;IACF;;;+BAEW;MAAA;;MACV,IAAI,KAAKgB,SAAT,EAAoB;QAClB,KAAKJ,aAAL,CAAmBX,QAAnB;MADF,OAEO;QACL,KAAKkB,SAAL;MACD;;MAED,KAAKb,aAAL,GAAqB,KAAKC,UAAL,CAClBa,MADkB,CACX,UAACC,GAAD,EAAMC,KAAN;QAAA,OAAgBD,MAAM,IAANA,GAAaE,MAAKR,kBAAlBM,GAAuC,IAAvCA,GAA8CC,MAAMhB,aAApE;MADW,GACwE,KAAKF,MAAL,CAAYoB,IAAZ,CAAiB,IAAjB,IAAyB,MADjG,KAElB,KAAKT,kBAAL,GAA0B,OAAO,KAAKA,kBAAZ,GAAiC,MAA3D,GAAoE,EAFlD,CAArB;IAGD;;;wCAEoB;MACnB,QAAQ,KAAKU,uBAAL,CAA6BC,KAArC;QACE,KAAK,QAAL;UACE,KAAKhB,WAAL,GAAmB,oCAAa,KAAKA,WAAlB,EAA+B,KAAKiB,OAApC,CAAnB;UACA;;QACF,KAAK,kBAAL;UAAyB;YACvB,KAAKjB,WAAL,GAAmB,KAAKA,WAAL,CAChBkB,OADgB,CACR,aADQ,EACO,EADP,EAEhBA,OAFgB,CAER,kBAFQ,EAEY,UAACC,CAAD,EAAIC,IAAJ;cAAA,OAAapC,OAAOC,YAAPD,CAAoBqC,SAASD,IAATC,EAAe,EAAfA,CAApBrC,CAAb;YAFZ,EAAnB;YAGA;UACD;MATH;IAWD;IAED;;;;;;;;uCAKoBM,MAAM;MACxB,IAAI,CAACA,IAAL,EAAW;QACT,KAAKgC,aAAL;;QACA,KAAK1B,aAAL,IAAsB,KAAKF,MAAL,CAAYoB,IAAZ,CAAiB,IAAjB,IAAyB,MAA/C;QACA,KAAKf,MAAL,GAAc,MAAd;QACA;MACD;;MAED,IAAIT,KAAKiC,KAALjC,CAAW,KAAXA,KAAqB,KAAKI,MAAL,CAAY8B,MAArC,EAA6C;QAC3C,KAAK9B,MAAL,CAAY,KAAKA,MAAL,CAAY8B,MAAZ,GAAqB,CAAjC,KAAuC,OAAOlC,IAA9C;MADF,OAEO;QACL,KAAKI,MAAL,CAAY+B,IAAZ,CAAiBnC,IAAjB;MACD;IACF;IAED;;;;;;oCAGiB;MACf,KAAK,IAAIoC,YAAY,KAAhB,EAAuBC,IAAI,CAA3B,EAA8BC,MAAM,KAAKlC,MAAL,CAAY8B,MAArD,EAA6DG,IAAIC,GAAjE,EAAsED,GAAtE,EAA2E;QACzE,IAAIX,QAAQ,KAAKtB,MAAL,CAAYiC,CAAZ,EAAexC,KAAf,CAAqB,GAArB,CAAZ;QACA,IAAM0C,MAAM,CAACb,MAAMc,KAANd,MAAiB,EAAlB,EAAsBe,IAAtB,GAA6BC,WAA7B,EAAZ;QACAhB,QAAQ,CAACA,MAAMF,IAANE,CAAW,GAAXA,KAAmB,EAApB,EAAwBE,OAAxB,CAAgC,KAAhC,EAAuC,EAAvC,EAA2Ca,IAA3C,EAARf;;QAEA,IAAIA,MAAMO,KAANP,CAAY,iBAAZA,CAAJ,EAAoC;UAClC,IAAI,CAAC,KAAKC,OAAV,EAAmB;YACjBS,YAAY,IAAZA;UACD,CAHiC,CAIlC;;;UACAV,QAAQ,8BAAO,+BAAQiB,QAAQjB,KAARiB,CAAR,EAAwB,KAAKhB,OAAL,IAAgB,YAAxC,CAAP,CAARD;QACD;;QAED,KAAKrB,OAAL,CAAakC,GAAb,IAAoB,CAAC,KAAKlC,OAAL,CAAakC,GAAb,KAAqB,EAAtB,EAA0BK,MAA1B,CAAiC,CAAC,KAAKC,iBAAL,CAAuBN,GAAvB,EAA4Bb,KAA5B,CAAD,CAAjC,CAApB;;QAEA,IAAI,CAAC,KAAKC,OAAN,IAAiBY,QAAQ,cAA7B,EAA6C;UAC3C,KAAKZ,OAAL,GAAe,KAAKtB,OAAL,CAAakC,GAAb,EAAkB,KAAKlC,OAAL,CAAakC,GAAb,EAAkBL,MAAlB,GAA2B,CAA7C,EAAgDY,MAAhD,CAAuDnB,OAAtE;QACD;;QAED,IAAIS,aAAa,KAAKT,OAAtB,EAA+B;UAC7B;UACAS,YAAY,KAAZA;UACA,KAAK/B,OAAL,GAAe,EAAf;UACAgC,IAAI,CAAC,CAALA,CAJ6B,CAItB;QACR;MACF;;MAED,KAAKU,gBAAL;;MACA,KAAKC,+BAAL;IACD;IAED;;;;;;;;;sCAMmBT,KAAKb,OAAO;MAC7B,IAAIuB,oBAAJ;MACA,IAAIC,YAAY,KAAhB;;MAEA,QAAQX,GAAR;QACE,KAAK,cAAL;QACA,KAAK,2BAAL;QACA,KAAK,qBAAL;QACA,KAAK,gBAAL;UACEU,cAAc,wCAAiBvB,KAAjB,CAAduB;UACA;;QACF,KAAK,MAAL;QACA,KAAK,QAAL;QACA,KAAK,IAAL;QACA,KAAK,UAAL;QACA,KAAK,IAAL;QACA,KAAK,KAAL;QACA,KAAK,kBAAL;QACA,KAAK,WAAL;QACA,KAAK,aAAL;QACA,KAAK,cAAL;UACEC,YAAY,IAAZA;UACAD,cAAc;YACZvB,OAAO,GAAGkB,MAAH,CAAU,oCAAalB,KAAb,KAAuB,EAAjC;UADK,CAAduB;UAGA;;QACF,KAAK,MAAL;UACEA,cAAc;YACZvB,OAAO,KAAKyB,UAAL,CAAgBzB,KAAhB;UADK,CAAduB;UAGA;;QACF;UACEA,cAAc;YACZvB,OAAOA;UADK,CAAduB;MA5BJ;;MAgCAA,YAAYG,OAAZH,GAAsBvB,KAAtBuB;;MAEA,KAAKI,oBAAL,CAA0BJ,WAA1B,EAAuC;QAAEC;MAAF,CAAvC;;MAEA,OAAOD,WAAP;IACD;IAED;;;;;;;;;;iCAOsB;MAAA,IAAVK,GAAU,uEAAJ,EAAI;MACpB,IAAMC,OAAO,IAAIC,IAAJ,CAASF,IAAIb,IAAJa,GAAW1B,OAAX0B,CAAmB,YAAnBA,EAAiC;QAAA,OAAMG,oBAASC,GAAGC,WAAHD,EAATD,KAA8B,OAApC;MAAjC,EAAT,CAAb;MACA,OAAQF,KAAKK,QAALL,OAAoB,cAApBA,GAAsCA,KAAKM,WAALN,GAAmB3B,OAAnB2B,CAA2B,KAA3BA,EAAkC,OAAlCA,CAAtCA,GAAmFD,GAA3F;IACD;;;yCAEqBQ,QAA4B;MAAA;;MAAA,+EAAJ,EAAI;MAAA,IAAlBZ,SAAkB,QAAlBA,SAAkB,EAChD;;;MACA,IAAI,OAAOY,OAAOpC,KAAd,KAAwB,QAA5B,EAAsC;QACpCoC,OAAOpC,KAAPoC,GAAe,uCAAgBA,OAAOpC,KAAvB,CAAfoC;MACD,CAJ+C,CAMhD;;;MACAC,OAAOC,IAAPD,CAAYD,OAAOhB,MAAPgB,IAAiB,EAA7BC,EAAiCjE,OAAjCiE,CAAyC,UAAUxB,GAAV,EAAe;QACtD,IAAI,OAAOuB,OAAOhB,MAAPgB,CAAcvB,GAAduB,CAAP,KAA8B,QAAlC,EAA4C;UAC1CA,OAAOhB,MAAPgB,CAAcvB,GAAduB,IAAqB,uCAAgBA,OAAOhB,MAAPgB,CAAcvB,GAAduB,CAAhB,CAArBA;QACD;MAHH,GAPgD,CAahD;;MACA,IAAIZ,aAAae,MAAMC,OAAND,CAAcH,OAAOpC,KAArBuC,CAAjB,EAA8C;QAC5CH,OAAOpC,KAAPoC,CAAahE,OAAbgE,CAAqB,gBAAQ;UAC3B,IAAIK,KAAKC,IAAT,EAAe;YACbD,KAAKC,IAALD,GAAY,uCAAgBA,KAAKC,IAArB,CAAZD;;YACA,IAAIF,MAAMC,OAAND,CAAcE,KAAKE,KAAnBJ,CAAJ,EAA+B;cAC7BK,OAAKjB,oBAAL,CAA0B;gBAAE3B,OAAOyC,KAAKE;cAAd,CAA1B,EAAiD;gBAAEnB,WAAW;cAAb,CAAjD;YACD;UACF;QANH;MAQD;;MAED,OAAOY,MAAP;IACD;IAED;;;;;;uCAGoB;MAClB,IAAMS,eAAe,wCAAiB,YAAjB,CAArB;MACA,KAAKC,WAAL,GAAmB,mBAAOD,YAAP,EAAqB,CAAC,SAAD,EAAY,cAAZ,EAA4B,GAA5B,CAArB,EAAuD,IAAvD,CAAnB;MACA,KAAKC,WAAL,CAAiB9C,KAAjB,GAAyB,CAAC,KAAK8C,WAAL,CAAiB9C,KAAjB,IAA0B,EAA3B,EAA+BgB,WAA/B,GAA6CD,IAA7C,EAAzB;MACA,KAAK+B,WAAL,CAAiBC,IAAjB,GAAyB,KAAKD,WAAL,CAAiB9C,KAAjB,CAAuB7B,KAAvB,CAA6B,GAA7B,EAAkC2C,KAAlC,MAA6C,MAAtE;;MAEA,IAAI,KAAKgC,WAAL,CAAiB1B,MAAjB,IAA2B,KAAK0B,WAAL,CAAiB1B,MAAjB,CAAwBnB,OAAnD,IAA8D,CAAC,KAAKA,OAAxE,EAAiF;QAC/E,KAAKA,OAAL,GAAe,KAAK6C,WAAL,CAAiB1B,MAAjB,CAAwBnB,OAAvC;MACD;;MAED,IAAI,KAAK6C,WAAL,CAAiBC,IAAjB,KAA0B,WAA1B,IAAyC,KAAKD,WAAL,CAAiB1B,MAAjB,CAAwB4B,QAArE,EAA+E;QAC7E,KAAKnE,UAAL,GAAkB,EAAlB;QACA,KAAKO,YAAL,GAAqB,KAAK0D,WAAL,CAAiB9C,KAAjB,CAAuB7B,KAAvB,CAA6B,GAA7B,EAAkC8E,GAAlC,MAA2C,OAAhE;QACA,KAAK5D,kBAAL,GAA0B,KAAKyD,WAAL,CAAiB1B,MAAjB,CAAwB4B,QAAlD;MACD;MAED;;;;;;;MAKA,IAAME,iCAAiC,wCAAiB,EAAjB,CAAvC;MACA,IAAMC,qBAAqB,mBAAOD,8BAAP,EAAuC,CAAC,SAAD,EAAY,qBAAZ,EAAmC,GAAnC,CAAvC,EAAgF,IAAhF,CAA3B;MACA,IAAME,eAAe,CAACD,mBAAmBnD,KAAnBmD,IAA4B,EAA7B,EAAiCnC,WAAjC,GAA+CD,IAA/C,OAA0D,YAA/E;MACA,IAAMsC,qBAAqB,CAACF,mBAAmBnD,KAAnBmD,IAA4B,EAA7B,EAAiCnC,WAAjC,GAA+CD,IAA/C,OAA0D,QAArF;;MACA,IAAI,CAACqC,gBAAgBC,kBAAjB,KAAwC,KAAKP,WAAL,CAAiBC,IAAjB,KAA0B,MAAlE,IAA4E,CAAC,KAAK9C,OAAtF,EAA+F;QAC7F,KAAKA,OAAL,GAAe,QAAf;MACD;;MAED,IAAI,KAAK6C,WAAL,CAAiB9C,KAAjB,KAA2B,gBAA3B,IAA+C,CAACoD,YAApD,EAAkE;QAChE;;;;QAIA,KAAKlE,aAAL,GAAqB,IAAIpB,QAAJ,CAAa,KAAKU,WAAlB,CAArB;QACA,KAAKK,UAAL,GAAkB,CAAC,KAAKK,aAAN,CAAlB;QACA,KAAKI,SAAL,GAAiB,IAAjB;MACD;IACF;IAED;;;;;;;sDAImC;MACjC,IAAMuD,eAAe,wCAAiB,MAAjB,CAArB;MACA,KAAK9C,uBAAL,GAA+B,mBAAO8C,YAAP,EAAqB,CAAC,SAAD,EAAY,2BAAZ,EAAyC,GAAzC,CAArB,EAAoE,IAApE,CAA/B;MACA,KAAK9C,uBAAL,CAA6BC,KAA7B,GAAqC,mBAAO,EAAP,EAAW,CAAC,yBAAD,EAA4B,OAA5B,CAAX,EAAiD,IAAjD,EAAuDgB,WAAvD,GAAqED,IAArE,EAArC;IACD;IAED;;;;;;;;;qCAMkBzC,MAAM;MACtB,IAAI,KAAKc,YAAT,EAAuB;QACrB,IAAId,SAAS,OAAO,KAAKe,kBAAzB,EAA6C;UAC3C,KAAKT,aAAL,IAAsBN,OAAO,IAA7B;;UACA,IAAI,KAAKY,aAAT,EAAwB;YACtB,KAAKA,aAAL,CAAmBX,QAAnB;UACD;;UACD,KAAKW,aAAL,GAAqB,IAAIpB,QAAJ,CAAa,KAAKU,WAAlB,CAArB;UACA,KAAKK,UAAL,CAAgB4B,IAAhB,CAAqB,KAAKvB,aAA1B;QANF,OAOO,IAAIZ,SAAS,OAAO,KAAKe,kBAAZ,GAAiC,IAA9C,EAAoD;UACzD,KAAKT,aAAL,IAAsBN,OAAO,IAA7B;;UACA,IAAI,KAAKY,aAAT,EAAwB;YACtB,KAAKA,aAAL,CAAmBX,QAAnB;UACD;;UACD,KAAKW,aAAL,GAAqB,KAArB;QALK,OAMA,IAAI,KAAKA,aAAT,EAAwB;UAC7B,KAAKA,aAAL,CAAmBb,SAAnB,CAA6BC,IAA7B;QADK,OAEA,CACL;QACD;MAlBH,OAmBO,IAAI,KAAKgB,SAAT,EAAoB;QACzB,KAAKJ,aAAL,CAAmBb,SAAnB,CAA6BC,IAA7B;MADK,OAEA;QACL,KAAKW,UAAL;;QAEA,QAAQ,KAAKc,uBAAL,CAA6BC,KAArC;UACE,KAAK,QAAL;YACE,KAAKhB,WAAL,IAAoBV,IAApB;YACA;;UACF,KAAK,kBAAL;YAAyB;cACvB,IAAIgF,UAAU,KAAKnE,cAAL,IAAuB,KAAKF,UAAL,GAAkB,CAAlB,GAAsB,IAAtB,GAA6B,EAApD,IAA0DX,IAAxE;cACA,IAAMiC,QAAQ+C,QAAQ/C,KAAR+C,CAAc,kBAAdA,CAAd;;cACA,IAAI/C,KAAJ,EAAW;gBACT,KAAKpB,cAAL,GAAsBoB,MAAM,CAANA,CAAtB;gBACA+C,UAAUA,QAAQC,MAARD,CAAe,CAAfA,EAAkBA,QAAQ9C,MAAR8C,GAAiB,KAAKnE,cAAL,CAAoBqB,MAAvD8C,CAAVA;cAFF,OAGO;gBACL,KAAKnE,cAAL,GAAsB,EAAtB;cACD;;cACD,KAAKH,WAAL,IAAoBsE,OAApB;cACA;YACD;;UACD,KAAK,MAAL;UACA,KAAK,MAAL;UACA;YACE,KAAKtE,WAAL,IAAoB,CAAC,KAAKC,UAAL,GAAkB,CAAlB,GAAsB,IAAtB,GAA6B,EAA9B,IAAoCX,IAAxD;YACA;QApBJ;MAsBD;IACF;IAED;;;;;;gCAGa;MACX,KAAKkF,iBAAL;;MACA,IAAI,KAAKpE,YAAL,IAAqB,CAAC,KAAKJ,WAA/B,EAA4C;QAC1C;MACD;;MAED,KAAKyE,kBAAL;;MACA,KAAKC,OAAL,GAAezC,QAAQ,KAAKjC,WAAbiC,CAAf;;MACA,KAAK0C,gBAAL;;MACA,KAAK3E,WAAL,GAAmB,EAAnB;IACD;;;yCAEqB;MACpB,IAAM4E,SAAS,wBAAwBC,IAAxB,CAA6B,KAAKf,WAAL,CAAiB9C,KAA9C,CAAf;MACA,IAAM8D,WAAW,YAAYD,IAAZ,CAAiB,mBAAO,EAAP,EAAW,CAAC,aAAD,EAAgB,QAAhB,EAA0B,QAA1B,CAAX,EAAgD,IAAhD,CAAjB,CAAjB;MACA,IAAI,CAACD,MAAD,IAAW,CAACE,QAAhB,EAA0B;MAE1B,IAAMC,QAAQ,SAASF,IAAT,CAAc,KAAKf,WAAL,CAAiB1B,MAAjB,CAAwB4C,KAAtC,CAAd;MACA,KAAKhF,WAAL,GAAmB,KAAKA,WAAL,CAAiBb,KAAjB,CAAuB,IAAvB,EAChBuB,MADgB,CACT,UAAUuE,aAAV,EAAyBC,YAAzB,EAAuC;QAC7C;QACA;QACA;QACA,IAAMC,gBAAgB,KAAKN,IAAL,CAAUI,aAAV,CAAtB;QACA,IAAMG,aAAa,aAAaP,IAAb,CAAkBI,aAAlB,CAAnB;QACA,OAAO,CAACF,QAAQE,cAAc/D,OAAd+D,CAAsB,OAAtBA,EAA+B,EAA/BA,CAARF,GAA6CE,aAA9C,KAAiEE,iBAAiB,CAACC,UAAlBD,GAAgC,EAAhCA,GAAqC,IAAtG,IAA8GD,YAArH;MAPe,GAShBhE,OATgB,CASR,MATQ,EASA,EATA,CAAnB,CANoB,CAeG;IACxB;;;uCAEmB;MAClB,IAAMiD,qBAAsB,KAAKxE,OAAL,CAAa,qBAAb,KAAuC,KAAKA,OAAL,CAAa,qBAAb,EAAoC,CAApC,CAAvC,IAAkF,wCAAiB,EAAjB,CAA9G;MACA,IAAM0F,SAAS,wBAAwBR,IAAxB,CAA6B,KAAKf,WAAL,CAAiB9C,KAA9C,CAAf;MACA,IAAMoD,eAAe,gBAAgBS,IAAhB,CAAqBV,mBAAmBnD,KAAxC,CAArB;;MACA,IAAIqE,UAAU,CAACjB,YAAf,EAA6B;QAC3B,IAAI,CAAC,KAAKnD,OAAN,IAAiB,gBAAgB4D,IAAhB,CAAqB,KAAKf,WAAL,CAAiB9C,KAAtC,CAArB,EAAmE;UACjE,KAAKC,OAAL,GAAe,KAAKqE,iBAAL,CAAuB,KAAKtF,WAA5B,CAAf;QACD,CAH0B,CAK3B;;;QACA,IAAI,CAAC,eAAe6E,IAAf,CAAoB,KAAK5D,OAAzB,CAAL,EAAwC;UACtC,KAAKyD,OAAL,GAAe,+BAAQzC,QAAQ,KAAKjC,WAAbiC,CAAR,EAAmC,KAAKhB,OAAL,IAAgB,YAAnD,CAAf;QADF,OAEO,IAAI,KAAKF,uBAAL,CAA6BC,KAA7B,KAAuC,QAA3C,EAAqD;UAC1D,KAAK0D,OAAL,GAAea,YAAY,KAAKvF,WAAjBuF,CAAf;QACD,CAV0B,CAY3B;;;QACA,KAAKtE,OAAL,GAAe,KAAK6C,WAAL,CAAiB1B,MAAjB,CAAwBnB,OAAxB,GAAkC,OAAjD;MACD;IACF;IAED;;;;;;;;;sCAMmBuE,MAAM;MACvB,IAAIvE,gBAAJ;MAAA,IAAawE,cAAb;MAEAD,OAAOA,KAAKtE,OAALsE,CAAa,WAAbA,EAA0B,GAA1BA,CAAPA;MACA,IAAIE,OAAOF,KAAKjE,KAALiE,CAAW,gDAAXA,CAAX;;MACA,IAAIE,IAAJ,EAAU;QACRD,QAAQC,KAAK,CAALA,CAARD;MACD;;MAED,IAAIA,KAAJ,EAAW;QACTxE,UAAUwE,MAAMlE,KAANkE,CAAY,oCAAZA,CAAVxE;;QACA,IAAIA,OAAJ,EAAa;UACXA,UAAU,CAACA,QAAQ,CAARA,KAAc,EAAf,EAAmBc,IAAnB,GAA0BC,WAA1B,EAAVf;QACD;MACF;;MAEDyE,OAAOF,KAAKjE,KAALiE,CAAW,uCAAXA,CAAPE;;MACA,IAAI,CAACzE,OAAD,IAAYyE,IAAhB,EAAsB;QACpBzE,UAAU,CAACyE,KAAK,CAALA,KAAW,EAAZ,EAAgB3D,IAAhB,GAAuBC,WAAvB,EAAVf;MACD;;MAED,OAAOA,OAAP;IACD;;;;;;AAGH,IAAMgB,UAAU,SAAVA,OAAU;EAAA,OAAO,IAAI0D,UAAJ,CAAe/C,IAAIzD,KAAJyD,CAAU,EAAVA,EAAcgD,GAAdhD,CAAkB;IAAA,OAAQiD,KAAKC,UAALD,CAAgB,CAAhBA,CAAR;EAAlB,EAAf,CAAP;AAAhB;;AACA,IAAMN,cAAc,SAAdA,WAAc;EAAA,OAAO,IAAIQ,yBAAJ,CAAgB,OAAhB,EAAyBC,MAAzB,CAAgCpD,GAAhC,CAAP;AAApB","names":["parse","MAXIMUM_NUMBER_OF_MIME_NODES","NodeCounter","_classCallCheck","count","Error","chunk","root","MimeNode","lines","String","fromCharCode","apply","split","forEach","writeLine","line","finalize","nodeCounter","bump","header","headers","bodystructure","childNodes","raw","_state","_bodyBuffer","_lineCount","_currentChild","_lineRemainder","_isMultipart","_multipartBoundary","_isRfc822","_processHeaderLine","_processBodyLine","_emitBody","reduce","agg","child","_this","join","contentTransferEncoding","value","charset","replace","m","code","parseInt","_parseHeaders","match","length","push","hasBinary","i","len","key","shift","trim","toLowerCase","str2arr","concat","_parseHeaderValue","params","fetchContentType","_processContentTransferEncoding","parsedValue","isAddress","_parseDate","initial","_decodeHeaderCharset","str","date","Date","timezone","tz","toUpperCase","toString","toUTCString","parsed","Object","keys","Array","isArray","addr","name","group","_this2","defaultValue","contentType","type","boundary","pop","defaultContentDispositionValue","contentDisposition","isAttachment","isInlineAttachment","curLine","substr","_decodeBodyBuffer","_processFlowedText","content","_processHtmlText","isText","test","isFlowed","delSp","delsp","previousValue","currentValue","endsWithSpace","isBoundary","isHtml","detectHTMLCharset","utf8Str2arr","html","input","meta","Uint8Array","map","char","charCodeAt","TextEncoder","encode"],"sources":["../src/mimeparser.js"],"sourcesContent":["import { pathOr } from 'ramda'\nimport timezone from './timezones'\nimport { decode, base64Decode, convert, parseHeaderValue, mimeWordsDecode } from 'emailjs-mime-codec'\nimport { TextEncoder } from 'text-encoding'\nimport parseAddress from 'emailjs-addressparser'\n\n/*\n * Counts MIME nodes to prevent memory exhaustion attacks (CWE-400)\n * see: https://snyk.io/vuln/npm:emailjs-mime-parser:20180625\n */\nconst MAXIMUM_NUMBER_OF_MIME_NODES = 999\nexport class NodeCounter {\n  constructor () {\n    this.count = 0\n  }\n  bump () {\n    if (++this.count > MAXIMUM_NUMBER_OF_MIME_NODES) {\n      throw new Error('Maximum number of MIME nodes exceeded!')\n    }\n  }\n}\n\nexport default function parse (chunk) {\n  const root = new MimeNode(new NodeCounter())\n  const lines = (typeof chunk === 'object' ? String.fromCharCode.apply(null, chunk) : chunk).split(/\\r?\\n/g)\n  lines.forEach(line => root.writeLine(line))\n  root.finalize()\n  return root\n}\n\nexport class MimeNode {\n  constructor (nodeCounter = new NodeCounter()) {\n    this.nodeCounter = nodeCounter\n    this.nodeCounter.bump()\n\n    this.header = [] // An array of unfolded header lines\n    this.headers = {} // An object that holds header key=value pairs\n    this.bodystructure = ''\n    this.childNodes = [] // If this is a multipart or message/rfc822 mime part, the value will be converted to array and hold all child nodes for this node\n    this.raw = '' // Stores the raw content of this node\n\n    this._state = 'HEADER' // Current state, always starts out with HEADER\n    this._bodyBuffer = '' // Body buffer\n    this._lineCount = 0 // Line counter bor the body part\n    this._currentChild = false // Active child node (if available)\n    this._lineRemainder = '' // Remainder string when dealing with base64 and qp values\n    this._isMultipart = false // Indicates if this is a multipart node\n    this._multipartBoundary = false // Stores boundary value for current multipart node\n    this._isRfc822 = false // Indicates if this is a message/rfc822 node\n  }\n\n  writeLine (line) {\n    this.raw += (this.raw ? '\\n' : '') + line\n\n    if (this._state === 'HEADER') {\n      this._processHeaderLine(line)\n    } else if (this._state === 'BODY') {\n      this._processBodyLine(line)\n    }\n  }\n\n  finalize () {\n    if (this._isRfc822) {\n      this._currentChild.finalize()\n    } else {\n      this._emitBody()\n    }\n\n    this.bodystructure = this.childNodes\n      .reduce((agg, child) => agg + '--' + this._multipartBoundary + '\\n' + child.bodystructure, this.header.join('\\n') + '\\n\\n') +\n      (this._multipartBoundary ? '--' + this._multipartBoundary + '--\\n' : '')\n  }\n\n  _decodeBodyBuffer () {\n    switch (this.contentTransferEncoding.value) {\n      case 'base64':\n        this._bodyBuffer = base64Decode(this._bodyBuffer, this.charset)\n        break\n      case 'quoted-printable': {\n        this._bodyBuffer = this._bodyBuffer\n          .replace(/=(\\r?\\n|$)/g, '')\n          .replace(/=([a-f0-9]{2})/ig, (m, code) => String.fromCharCode(parseInt(code, 16)))\n        break\n      }\n    }\n  }\n\n  /**\n   * Processes a line in the HEADER state. It the line is empty, change state to BODY\n   *\n   * @param {String} line Entire input line as 'binary' string\n   */\n  _processHeaderLine (line) {\n    if (!line) {\n      this._parseHeaders()\n      this.bodystructure += this.header.join('\\n') + '\\n\\n'\n      this._state = 'BODY'\n      return\n    }\n\n    if (line.match(/^\\s/) && this.header.length) {\n      this.header[this.header.length - 1] += '\\n' + line\n    } else {\n      this.header.push(line)\n    }\n  }\n\n  /**\n   * Joins folded header lines and calls Content-Type and Transfer-Encoding processors\n   */\n  _parseHeaders () {\n    for (let hasBinary = false, i = 0, len = this.header.length; i < len; i++) {\n      let value = this.header[i].split(':')\n      const key = (value.shift() || '').trim().toLowerCase()\n      value = (value.join(':') || '').replace(/\\n/g, '').trim()\n\n      if (value.match(/[\\u0080-\\uFFFF]/)) {\n        if (!this.charset) {\n          hasBinary = true\n        }\n        // use default charset at first and if the actual charset is resolved, the conversion is re-run\n        value = decode(convert(str2arr(value), this.charset || 'iso-8859-1'))\n      }\n\n      this.headers[key] = (this.headers[key] || []).concat([this._parseHeaderValue(key, value)])\n\n      if (!this.charset && key === 'content-type') {\n        this.charset = this.headers[key][this.headers[key].length - 1].params.charset\n      }\n\n      if (hasBinary && this.charset) {\n        // reset values and start over once charset has been resolved and 8bit content has been found\n        hasBinary = false\n        this.headers = {}\n        i = -1 // next iteration has i == 0\n      }\n    }\n\n    this.fetchContentType()\n    this._processContentTransferEncoding()\n  }\n\n  /**\n   * Parses single header value\n   * @param {String} key Header key\n   * @param {String} value Value for the key\n   * @return {Object} parsed header\n   */\n  _parseHeaderValue (key, value) {\n    let parsedValue\n    let isAddress = false\n\n    switch (key) {\n      case 'content-type':\n      case 'content-transfer-encoding':\n      case 'content-disposition':\n      case 'dkim-signature':\n        parsedValue = parseHeaderValue(value)\n        break\n      case 'from':\n      case 'sender':\n      case 'to':\n      case 'reply-to':\n      case 'cc':\n      case 'bcc':\n      case 'abuse-reports-to':\n      case 'errors-to':\n      case 'return-path':\n      case 'delivered-to':\n        isAddress = true\n        parsedValue = {\n          value: [].concat(parseAddress(value) || [])\n        }\n        break\n      case 'date':\n        parsedValue = {\n          value: this._parseDate(value)\n        }\n        break\n      default:\n        parsedValue = {\n          value: value\n        }\n    }\n    parsedValue.initial = value\n\n    this._decodeHeaderCharset(parsedValue, { isAddress })\n\n    return parsedValue\n  }\n\n  /**\n   * Checks if a date string can be parsed. Falls back replacing timezone\n   * abbrevations with timezone values. Bogus timezones default to UTC.\n   *\n   * @param {String} str Date header\n   * @returns {String} UTC date string if parsing succeeded, otherwise returns input value\n   */\n  _parseDate (str = '') {\n    const date = new Date(str.trim().replace(/\\b[a-z]+$/i, tz => timezone[tz.toUpperCase()] || '+0000'))\n    return (date.toString() !== 'Invalid Date') ? date.toUTCString().replace(/GMT/, '+0000') : str\n  }\n\n  _decodeHeaderCharset (parsed, { isAddress } = {}) {\n    // decode default value\n    if (typeof parsed.value === 'string') {\n      parsed.value = mimeWordsDecode(parsed.value)\n    }\n\n    // decode possible params\n    Object.keys(parsed.params || {}).forEach(function (key) {\n      if (typeof parsed.params[key] === 'string') {\n        parsed.params[key] = mimeWordsDecode(parsed.params[key])\n      }\n    })\n\n    // decode addresses\n    if (isAddress && Array.isArray(parsed.value)) {\n      parsed.value.forEach(addr => {\n        if (addr.name) {\n          addr.name = mimeWordsDecode(addr.name)\n          if (Array.isArray(addr.group)) {\n            this._decodeHeaderCharset({ value: addr.group }, { isAddress: true })\n          }\n        }\n      })\n    }\n\n    return parsed\n  }\n\n  /**\n   * Parses Content-Type value and selects following actions.\n   */\n  fetchContentType () {\n    const defaultValue = parseHeaderValue('text/plain')\n    this.contentType = pathOr(defaultValue, ['headers', 'content-type', '0'])(this)\n    this.contentType.value = (this.contentType.value || '').toLowerCase().trim()\n    this.contentType.type = (this.contentType.value.split('/').shift() || 'text')\n\n    if (this.contentType.params && this.contentType.params.charset && !this.charset) {\n      this.charset = this.contentType.params.charset\n    }\n\n    if (this.contentType.type === 'multipart' && this.contentType.params.boundary) {\n      this.childNodes = []\n      this._isMultipart = (this.contentType.value.split('/').pop() || 'mixed')\n      this._multipartBoundary = this.contentType.params.boundary\n    }\n\n    /**\n     * For attachment (inline/regular) if charset is not defined and attachment is non-text/*,\n     * then default charset to binary.\n     * Refer to issue: https://github.com/emailjs/emailjs-mime-parser/issues/18\n     */\n    const defaultContentDispositionValue = parseHeaderValue('')\n    const contentDisposition = pathOr(defaultContentDispositionValue, ['headers', 'content-disposition', '0'])(this)\n    const isAttachment = (contentDisposition.value || '').toLowerCase().trim() === 'attachment'\n    const isInlineAttachment = (contentDisposition.value || '').toLowerCase().trim() === 'inline'\n    if ((isAttachment || isInlineAttachment) && this.contentType.type !== 'text' && !this.charset) {\n      this.charset = 'binary'\n    }\n\n    if (this.contentType.value === 'message/rfc822' && !isAttachment) {\n      /**\n       * Parse message/rfc822 only if the mime part is not marked with content-disposition: attachment,\n       * otherwise treat it like a regular attachment\n       */\n      this._currentChild = new MimeNode(this.nodeCounter)\n      this.childNodes = [this._currentChild]\n      this._isRfc822 = true\n    }\n  }\n\n  /**\n   * Parses Content-Transfer-Encoding value to see if the body needs to be converted\n   * before it can be emitted\n   */\n  _processContentTransferEncoding () {\n    const defaultValue = parseHeaderValue('7bit')\n    this.contentTransferEncoding = pathOr(defaultValue, ['headers', 'content-transfer-encoding', '0'])(this)\n    this.contentTransferEncoding.value = pathOr('', ['contentTransferEncoding', 'value'])(this).toLowerCase().trim()\n  }\n\n  /**\n   * Processes a line in the BODY state. If this is a multipart or rfc822 node,\n   * passes line value to child nodes.\n   *\n   * @param {String} line Entire input line as 'binary' string\n   */\n  _processBodyLine (line) {\n    if (this._isMultipart) {\n      if (line === '--' + this._multipartBoundary) {\n        this.bodystructure += line + '\\n'\n        if (this._currentChild) {\n          this._currentChild.finalize()\n        }\n        this._currentChild = new MimeNode(this.nodeCounter)\n        this.childNodes.push(this._currentChild)\n      } else if (line === '--' + this._multipartBoundary + '--') {\n        this.bodystructure += line + '\\n'\n        if (this._currentChild) {\n          this._currentChild.finalize()\n        }\n        this._currentChild = false\n      } else if (this._currentChild) {\n        this._currentChild.writeLine(line)\n      } else {\n        // Ignore multipart preamble\n      }\n    } else if (this._isRfc822) {\n      this._currentChild.writeLine(line)\n    } else {\n      this._lineCount++\n\n      switch (this.contentTransferEncoding.value) {\n        case 'base64':\n          this._bodyBuffer += line\n          break\n        case 'quoted-printable': {\n          let curLine = this._lineRemainder + (this._lineCount > 1 ? '\\n' : '') + line\n          const match = curLine.match(/=[a-f0-9]{0,1}$/i)\n          if (match) {\n            this._lineRemainder = match[0]\n            curLine = curLine.substr(0, curLine.length - this._lineRemainder.length)\n          } else {\n            this._lineRemainder = ''\n          }\n          this._bodyBuffer += curLine\n          break\n        }\n        case '7bit':\n        case '8bit':\n        default:\n          this._bodyBuffer += (this._lineCount > 1 ? '\\n' : '') + line\n          break\n      }\n    }\n  }\n\n  /**\n   * Emits a chunk of the body\n  */\n  _emitBody () {\n    this._decodeBodyBuffer()\n    if (this._isMultipart || !this._bodyBuffer) {\n      return\n    }\n\n    this._processFlowedText()\n    this.content = str2arr(this._bodyBuffer)\n    this._processHtmlText()\n    this._bodyBuffer = ''\n  }\n\n  _processFlowedText () {\n    const isText = /^text\\/(plain|html)$/i.test(this.contentType.value)\n    const isFlowed = /^flowed$/i.test(pathOr('', ['contentType', 'params', 'format'])(this))\n    if (!isText || !isFlowed) return\n\n    const delSp = /^yes$/i.test(this.contentType.params.delsp)\n    this._bodyBuffer = this._bodyBuffer.split('\\n')\n      .reduce(function (previousValue, currentValue) {\n        // remove soft linebreaks after space symbols.\n        // delsp adds spaces to text to be able to fold it.\n        // these spaces can be removed once the text is unfolded\n        const endsWithSpace = / $/.test(previousValue)\n        const isBoundary = /(^|\\n)-- $/.test(previousValue)\n        return (delSp ? previousValue.replace(/[ ]+$/, '') : previousValue) + ((endsWithSpace && !isBoundary) ? '' : '\\n') + currentValue\n      })\n      .replace(/^ /gm, '') // remove whitespace stuffing http://tools.ietf.org/html/rfc3676#section-4.4\n  }\n\n  _processHtmlText () {\n    const contentDisposition = (this.headers['content-disposition'] && this.headers['content-disposition'][0]) || parseHeaderValue('')\n    const isHtml = /^text\\/(plain|html)$/i.test(this.contentType.value)\n    const isAttachment = /^attachment$/i.test(contentDisposition.value)\n    if (isHtml && !isAttachment) {\n      if (!this.charset && /^text\\/html$/i.test(this.contentType.value)) {\n        this.charset = this.detectHTMLCharset(this._bodyBuffer)\n      }\n\n      // decode \"binary\" string to an unicode string\n      if (!/^utf[-_]?8$/i.test(this.charset)) {\n        this.content = convert(str2arr(this._bodyBuffer), this.charset || 'iso-8859-1')\n      } else if (this.contentTransferEncoding.value === 'base64') {\n        this.content = utf8Str2arr(this._bodyBuffer)\n      }\n\n      // override charset for text nodes\n      this.charset = this.contentType.params.charset = 'utf-8'\n    }\n  }\n\n  /**\n   * Detect charset from a html file\n   *\n   * @param {String} html Input HTML\n   * @returns {String} Charset if found or undefined\n   */\n  detectHTMLCharset (html) {\n    let charset, input\n\n    html = html.replace(/\\r?\\n|\\r/g, ' ')\n    let meta = html.match(/<meta\\s+http-equiv=[\"'\\s]*content-type[^>]*?>/i)\n    if (meta) {\n      input = meta[0]\n    }\n\n    if (input) {\n      charset = input.match(/charset\\s?=\\s?([a-zA-Z\\-_:0-9]*);?/)\n      if (charset) {\n        charset = (charset[1] || '').trim().toLowerCase()\n      }\n    }\n\n    meta = html.match(/<meta\\s+charset=[\"'\\s]*([^\"'<>/\\s]+)/i)\n    if (!charset && meta) {\n      charset = (meta[1] || '').trim().toLowerCase()\n    }\n\n    return charset\n  }\n}\n\nconst str2arr = str => new Uint8Array(str.split('').map(char => char.charCodeAt(0)))\nconst utf8Str2arr = str => new TextEncoder('utf-8').encode(str)\n"]},"metadata":{},"sourceType":"script"}