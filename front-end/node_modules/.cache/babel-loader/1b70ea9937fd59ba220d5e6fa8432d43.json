{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar OUTPUT_STRING = exports.OUTPUT_STRING = 'OUTPUT_STRING';\nvar OUTPUT_TYPED_ARRAY = exports.OUTPUT_TYPED_ARRAY = 'OUTPUT_TYPED_ARRAY';\n\nvar arr2str = function arr2str(arr) {\n  return String.fromCharCode.apply(null, arr);\n};\n\nexports.default = function (base64Str) {\n  var outputEncoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : OUTPUT_STRING;\n  return outputEncoding === OUTPUT_STRING ? arr2str(decode(base64Str)) : decode(base64Str);\n};\n\nfunction decode(base64Str) {\n  var iOut = 0;\n  var arr = new Uint8Array(Math.ceil(base64Str.length * 3 / 4));\n\n  for (var i = 0, len = base64Str.length, validBits = 0, bitsSoFar = 0; i < len; i++) {\n    var bits = void 0;\n    var c = base64Str.charCodeAt(i);\n\n    if (c >= 0x41 && c <= 0x5a) {\n      // [A-Z]\n      bits = c - 0x41;\n    } else if (c >= 0x61 && c <= 0x7a) {\n      // [a-z]\n      bits = c - 0x61 + 0x1a;\n    } else if (c >= 0x30 && c <= 0x39) {\n      // [0-9]\n      bits = c - 0x30 + 0x34;\n    } else if (c === 0x2b) {\n      // +\n      bits = 0x3e;\n    } else if (c === 0x2f) {\n      // /\n      bits = 0x3f;\n    } else if (c === 0x3d) {\n      // =\n      validBits = 0;\n      continue;\n    } else {\n      // ignore all other characters!\n      continue;\n    }\n\n    bitsSoFar = bitsSoFar << 6 | bits;\n    validBits += 6;\n\n    if (validBits >= 8) {\n      validBits -= 8;\n      arr[iOut++] = bitsSoFar >> validBits;\n\n      if (validBits === 2) {\n        bitsSoFar &= 0x03;\n      } else if (validBits === 4) {\n        bitsSoFar &= 0x0f;\n      }\n    }\n  }\n\n  return iOut < arr.length ? arr.subarray(0, iOut) : arr;\n}","map":{"version":3,"mappings":";;;;;AAAO,IAAMA,wCAAgB,eAAtB;AACA,IAAMC,kDAAqB,oBAA3B;;AAEP,IAAMC,UAAU,SAAVA,OAAU;EAAA,OAAOC,OAAOC,YAAPD,CAAoBE,KAApBF,CAA0B,IAA1BA,EAAgCG,GAAhCH,CAAP;AAAhB;;kBAEe,UAACI,SAAD;EAAA,IAAYC,cAAZ,uEAA6BR,aAA7B;EAAA,OACZQ,mBAAmBR,aAAnBQ,GAAoCN,QAAQO,OAAOF,SAAPE,CAARP,CAApCM,GAAiEC,OAAOF,SAAPE,CADrD;;;AAGf,SAASA,MAAT,CAAiBF,SAAjB,EAA4B;EAC1B,IAAIG,OAAO,CAAX;EACA,IAAMJ,MAAM,IAAIK,UAAJ,CAAeC,KAAKC,IAALD,CAAUL,UAAUO,MAAVP,GAAmB,CAAnBA,GAAuB,CAAjCK,CAAf,CAAZ;;EAEA,KAAK,IAAIG,IAAI,CAAR,EAAWC,MAAMT,UAAUO,MAA3B,EAAmCG,YAAY,CAA/C,EAAkDC,YAAY,CAAnE,EAAsEH,IAAIC,GAA1E,EAA+ED,GAA/E,EAAoF;IAClF,IAAII,aAAJ;IACA,IAAMC,IAAIb,UAAUc,UAAVd,CAAqBQ,CAArBR,CAAV;;IACA,IAAIa,KAAK,IAALA,IAAaA,KAAK,IAAtB,EAA4B;MAAE;MAC5BD,OAAOC,IAAI,IAAXD;IADF,OAEO,IAAIC,KAAK,IAALA,IAAaA,KAAK,IAAtB,EAA4B;MAAE;MACnCD,OAAOC,IAAI,IAAJA,GAAW,IAAlBD;IADK,OAEA,IAAIC,KAAK,IAALA,IAAaA,KAAK,IAAtB,EAA4B;MAAE;MACnCD,OAAOC,IAAI,IAAJA,GAAW,IAAlBD;IADK,OAEA,IAAIC,MAAM,IAAV,EAAgB;MAAE;MACvBD,OAAO,IAAPA;IADK,OAEA,IAAIC,MAAM,IAAV,EAAgB;MAAE;MACvBD,OAAO,IAAPA;IADK,OAEA,IAAIC,MAAM,IAAV,EAAgB;MAAE;MACvBH,YAAY,CAAZA;MACA;IAFK,OAGA;MACL;MACA;IACD;;IACDC,YAAaA,aAAa,CAAbA,GAAkBC,IAA/BD;IACAD,aAAa,CAAbA;;IACA,IAAIA,aAAa,CAAjB,EAAoB;MAClBA,aAAa,CAAbA;MACAX,IAAII,MAAJJ,IAAcY,aAAaD,SAA3BX;;MACA,IAAIW,cAAc,CAAlB,EAAqB;QACnBC,aAAa,IAAbA;MADF,OAEO,IAAID,cAAc,CAAlB,EAAqB;QAC1BC,aAAa,IAAbA;MACD;IACF;EACF;;EAED,OAAQR,OAAOJ,IAAIQ,MAAXJ,GAAqBJ,IAAIgB,QAAJhB,CAAa,CAAbA,EAAgBI,IAAhBJ,CAArBI,GAA6CJ,GAArD;AACD","names":["OUTPUT_STRING","OUTPUT_TYPED_ARRAY","arr2str","String","fromCharCode","apply","arr","base64Str","outputEncoding","decode","iOut","Uint8Array","Math","ceil","length","i","len","validBits","bitsSoFar","bits","c","charCodeAt","subarray"],"sources":["../src/base64-decode.js"],"sourcesContent":["export const OUTPUT_STRING = 'OUTPUT_STRING'\nexport const OUTPUT_TYPED_ARRAY = 'OUTPUT_TYPED_ARRAY'\n\nconst arr2str = arr => String.fromCharCode.apply(null, arr)\n\nexport default (base64Str, outputEncoding = OUTPUT_STRING) =>\n  (outputEncoding === OUTPUT_STRING) ? arr2str(decode(base64Str)) : decode(base64Str)\n\nfunction decode (base64Str) {\n  let iOut = 0\n  const arr = new Uint8Array(Math.ceil(base64Str.length * 3 / 4))\n\n  for (let i = 0, len = base64Str.length, validBits = 0, bitsSoFar = 0; i < len; i++) {\n    let bits\n    const c = base64Str.charCodeAt(i)\n    if (c >= 0x41 && c <= 0x5a) { // [A-Z]\n      bits = c - 0x41\n    } else if (c >= 0x61 && c <= 0x7a) { // [a-z]\n      bits = c - 0x61 + 0x1a\n    } else if (c >= 0x30 && c <= 0x39) { // [0-9]\n      bits = c - 0x30 + 0x34\n    } else if (c === 0x2b) { // +\n      bits = 0x3e\n    } else if (c === 0x2f) { // /\n      bits = 0x3f\n    } else if (c === 0x3d) { // =\n      validBits = 0\n      continue\n    } else {\n      // ignore all other characters!\n      continue\n    }\n    bitsSoFar = (bitsSoFar << 6) | bits\n    validBits += 6\n    if (validBits >= 8) {\n      validBits -= 8\n      arr[iOut++] = bitsSoFar >> validBits\n      if (validBits === 2) {\n        bitsSoFar &= 0x03\n      } else if (validBits === 4) {\n        bitsSoFar &= 0x0f\n      }\n    }\n  }\n\n  return (iOut < arr.length) ? arr.subarray(0, iOut) : arr\n}\n"]},"metadata":{},"sourceType":"script"}