{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.convert = exports.arr2str = exports.encode = undefined;\nexports.decode = decode;\n\nvar _textEncoding = require('text-encoding');\n/**\n * Encodes an unicode string into an Uint8Array object as UTF-8\n *\n * @param {String} str String to be encoded\n * @return {Uint8Array} UTF-8 encoded typed array\n */\n\n\nvar encode = exports.encode = function encode(str) {\n  return new _textEncoding.TextEncoder('UTF-8').encode(str);\n};\n\nvar arr2str = exports.arr2str = function arr2str(arr) {\n  var CHUNK_SZ = 0x8000;\n  var strs = [];\n\n  for (var i = 0; i < arr.length; i += CHUNK_SZ) {\n    strs.push(String.fromCharCode.apply(null, arr.subarray(i, i + CHUNK_SZ)));\n  }\n\n  return strs.join('');\n};\n/**\n * Decodes a string from Uint8Array to an unicode string using specified encoding\n *\n * @param {Uint8Array} buf Binary data to be decoded\n * @param {String} Binary data is decoded into string using this charset\n * @return {String} Decoded string\n */\n\n\nfunction decode(buf) {\n  var fromCharset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'utf-8';\n  var charsets = [{\n    charset: normalizeCharset(fromCharset),\n    fatal: false\n  }, {\n    charset: 'utf-8',\n    fatal: true\n  }, {\n    charset: 'iso-8859-15',\n    fatal: false\n  }];\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = charsets[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var _step$value = _step.value,\n          charset = _step$value.charset,\n          fatal = _step$value.fatal;\n\n      try {\n        return new _textEncoding.TextDecoder(charset, {\n          fatal: fatal\n        }).decode(buf);\n      } catch (e) {}\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return arr2str(buf); // all else fails, treat it as binary\n}\n/**\n * Convert a string from specific encoding to UTF-8 Uint8Array\n *\n * @param {String|Uint8Array} data Data to be encoded\n * @param {String} Source encoding for the string (optional for data of type String)\n * @return {Uint8Array} UTF-8 encoded typed array\n */\n\n\nvar convert = exports.convert = function convert(data, fromCharset) {\n  return typeof data === 'string' ? encode(data) : encode(decode(data, fromCharset));\n};\n\nfunction normalizeCharset() {\n  var charset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'utf-8';\n  var match = void 0;\n\n  if (match = charset.match(/^utf[-_]?(\\d+)$/i)) {\n    return 'UTF-' + match[1];\n  }\n\n  if (match = charset.match(/^win[-_]?(\\d+)$/i)) {\n    return 'WINDOWS-' + match[1];\n  }\n\n  if (match = charset.match(/^latin[-_]?(\\d+)$/i)) {\n    return 'ISO-8859-' + match[1];\n  }\n\n  return charset;\n}","map":{"version":3,"mappings":";;;;;;QA4BgBA;;AA5BhB;AAEA;;;;;;;;AAMO,IAAMC,0BAAS,SAATA,MAAS;EAAA,OAAO,IAAIC,yBAAJ,CAAgB,OAAhB,EAAyBD,MAAzB,CAAgCE,GAAhC,CAAP;AAAf;;AAEA,IAAMC,4BAAU,SAAVA,OAAU,MAAO;EAC5B,IAAMC,WAAW,MAAjB;EACA,IAAMC,OAAO,EAAb;;EAEA,KAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAIC,IAAIC,MAAxB,EAAgCF,KAAKF,QAArC,EAA+C;IAC7CC,KAAKI,IAALJ,CAAUK,OAAOC,YAAPD,CAAoBE,KAApBF,CAA0B,IAA1BA,EAAgCH,IAAIM,QAAJN,CAAaD,CAAbC,EAAgBD,IAAIF,QAApBG,CAAhCG,CAAVL;EACD;;EAED,OAAOA,KAAKS,IAALT,CAAU,EAAVA,CAAP;AARK;AAWP;;;;;;;;;AAOO,SAASN,MAAT,CAAiBgB,GAAjB,EAA6C;EAAA,IAAvBC,WAAuB,uEAAT,OAAS;EAClD,IAAMC,WAAW,CACf;IAAEC,SAASC,iBAAiBH,WAAjBG,CAAX;IAA0CC,OAAO;EAAjD,CADe,EAEf;IAAEF,SAAS,OAAX;IAAoBE,OAAO;EAA3B,CAFe,EAGf;IAAEF,SAAS,aAAX;IAA0BE,OAAO;EAAjC,CAHe,CAAjB;EADkD;EAAA;EAAA;;EAAA;IAOlD,qBAAiCH,QAAjC,iBAAiCA,EAAjC,2GAA2C;MAAA;MAAA,IAA9BC,OAA8B,eAA9BA,OAA8B;MAAA,IAArBE,KAAqB,eAArBA,KAAqB;;MACzC,IAAI;QAAE,OAAO,IAAIC,yBAAJ,CAAgBH,OAAhB,EAAyB;UAAEE;QAAF,CAAzB,EAAoCrB,MAApC,CAA2CgB,GAA3C,CAAP;MAAN,EAA+D,OAAOO,CAAP,EAAU,CAAG;IAC7E;EATiD;IAAAC;IAAAC;EAAA;IAAA;MAAA;QAAAC;MAAA;IAAA;MAAA;QAAA;MAAA;IAAA;EAAA;;EAWlD,OAAOtB,QAAQY,GAARZ,CAAP,CAXkD,CAW9B;AACrB;AAED;;;;;;;;;AAOO,IAAMuB,4BAAU,SAAVA,OAAU,CAACC,IAAD,EAAOX,WAAP;EAAA,OAAuB,OAAOW,IAAP,KAAgB,QAAhB,GAA2B3B,OAAO2B,IAAP3B,CAA3B,GAA0CA,OAAOD,OAAO4B,IAAP5B,EAAaiB,WAAbjB,CAAPC,CAAjE;AAAhB;;AAEP,SAASmB,gBAAT,GAA8C;EAAA,IAAnBD,OAAmB,uEAAT,OAAS;EAC5C,IAAIU,cAAJ;;EAEA,IAAKA,QAAQV,QAAQU,KAARV,CAAc,kBAAdA,CAAb,EAAiD;IAC/C,OAAO,SAASU,MAAM,CAANA,CAAhB;EACD;;EAED,IAAKA,QAAQV,QAAQU,KAARV,CAAc,kBAAdA,CAAb,EAAiD;IAC/C,OAAO,aAAaU,MAAM,CAANA,CAApB;EACD;;EAED,IAAKA,QAAQV,QAAQU,KAARV,CAAc,oBAAdA,CAAb,EAAmD;IACjD,OAAO,cAAcU,MAAM,CAANA,CAArB;EACD;;EAED,OAAOV,OAAP;AACD","names":["decode","encode","TextEncoder","str","arr2str","CHUNK_SZ","strs","i","arr","length","push","String","fromCharCode","apply","subarray","join","buf","fromCharset","charsets","charset","normalizeCharset","fatal","TextDecoder","e","_didIteratorError","_iteratorError","_iterator","convert","data","match"],"sources":["../src/charset.js"],"sourcesContent":["import { TextDecoder, TextEncoder } from 'text-encoding'\n\n/**\n * Encodes an unicode string into an Uint8Array object as UTF-8\n *\n * @param {String} str String to be encoded\n * @return {Uint8Array} UTF-8 encoded typed array\n */\nexport const encode = str => new TextEncoder('UTF-8').encode(str)\n\nexport const arr2str = arr => {\n  const CHUNK_SZ = 0x8000\n  const strs = []\n\n  for (let i = 0; i < arr.length; i += CHUNK_SZ) {\n    strs.push(String.fromCharCode.apply(null, arr.subarray(i, i + CHUNK_SZ)))\n  }\n\n  return strs.join('')\n}\n\n/**\n * Decodes a string from Uint8Array to an unicode string using specified encoding\n *\n * @param {Uint8Array} buf Binary data to be decoded\n * @param {String} Binary data is decoded into string using this charset\n * @return {String} Decoded string\n */\nexport function decode (buf, fromCharset = 'utf-8') {\n  const charsets = [\n    { charset: normalizeCharset(fromCharset), fatal: false },\n    { charset: 'utf-8', fatal: true },\n    { charset: 'iso-8859-15', fatal: false }\n  ]\n\n  for (const { charset, fatal } of charsets) {\n    try { return new TextDecoder(charset, { fatal }).decode(buf) } catch (e) { }\n  }\n\n  return arr2str(buf) // all else fails, treat it as binary\n}\n\n/**\n * Convert a string from specific encoding to UTF-8 Uint8Array\n *\n * @param {String|Uint8Array} data Data to be encoded\n * @param {String} Source encoding for the string (optional for data of type String)\n * @return {Uint8Array} UTF-8 encoded typed array\n */\nexport const convert = (data, fromCharset) => typeof data === 'string' ? encode(data) : encode(decode(data, fromCharset))\n\nfunction normalizeCharset (charset = 'utf-8') {\n  let match\n\n  if ((match = charset.match(/^utf[-_]?(\\d+)$/i))) {\n    return 'UTF-' + match[1]\n  }\n\n  if ((match = charset.match(/^win[-_]?(\\d+)$/i))) {\n    return 'WINDOWS-' + match[1]\n  }\n\n  if ((match = charset.match(/^latin[-_]?(\\d+)$/i))) {\n    return 'ISO-8859-' + match[1]\n  }\n\n  return charset\n}\n"]},"metadata":{},"sourceType":"script"}