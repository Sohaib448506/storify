{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.convert = exports.encode = exports.decode = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nexports.mimeEncode = mimeEncode;\nexports.mimeDecode = mimeDecode;\nexports.base64Encode = base64Encode;\nexports.base64Decode = base64Decode;\nexports.quotedPrintableEncode = quotedPrintableEncode;\nexports.quotedPrintableDecode = quotedPrintableDecode;\nexports.mimeWordEncode = mimeWordEncode;\nexports.mimeWordsEncode = mimeWordsEncode;\nexports.mimeWordDecode = mimeWordDecode;\nexports.mimeWordsDecode = mimeWordsDecode;\nexports.foldLines = foldLines;\nexports.headerLineEncode = headerLineEncode;\nexports.headerLineDecode = headerLineDecode;\nexports.headerLinesDecode = headerLinesDecode;\nexports.parseHeaderValue = parseHeaderValue;\nexports.continuationEncode = continuationEncode;\n\nvar _emailjsBase = require('emailjs-base64');\n\nvar _charset = require('./charset');\n\nvar _ramda = require('ramda'); // Lines can't be longer than 76 + <CR><LF> = 78 bytes\n// http://tools.ietf.org/html/rfc2045#section-6.7\n\n\nvar MAX_LINE_LENGTH = 76;\nvar MAX_MIME_WORD_LENGTH = 52;\nvar MAX_B64_MIME_WORD_BYTE_LENGTH = 39;\n/**\n * Encodes all non printable and non ascii bytes to =XX form, where XX is the\n * byte value in hex. This function does not convert linebreaks etc. it\n * only escapes character sequences\n *\n * @param {String|Uint8Array} data Either a string or an Uint8Array\n * @param {String} [fromCharset='UTF-8'] Source encoding\n * @return {String} Mime encoded string\n */\n\nfunction mimeEncode() {\n  var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var fromCharset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'UTF-8';\n  var buffer = (0, _charset.convert)(data, fromCharset);\n  return buffer.reduce(function (aggregate, ord, index) {\n    return _checkRanges(ord) && !((ord === 0x20 || ord === 0x09) && (index === buffer.length - 1 || buffer[index + 1] === 0x0a || buffer[index + 1] === 0x0d)) ? aggregate + String.fromCharCode(ord) // if the char is in allowed range, then keep as is, unless it is a ws in the end of a line\n    : aggregate + '=' + (ord < 0x10 ? '0' : '') + ord.toString(16).toUpperCase();\n  }, '');\n\n  function _checkRanges(nr) {\n    var ranges = [// https://tools.ietf.org/html/rfc2045#section-6.7\n    [0x09], // <TAB>\n    [0x0A], // <LF>\n    [0x0D], // <CR>\n    [0x20, 0x3C], // <SP>!\"#$%&'()*+,-./0123456789:;\n    [0x3E, 0x7E] // >?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}\n    ];\n    return ranges.reduce(function (val, range) {\n      return val || range.length === 1 && nr === range[0] || range.length === 2 && nr >= range[0] && nr <= range[1];\n    }, false);\n  }\n}\n/**\n * Decodes mime encoded string to an unicode string\n *\n * @param {String} str Mime encoded string\n * @param {String} [fromCharset='UTF-8'] Source encoding\n * @return {String} Decoded unicode string\n */\n\n\nfunction mimeDecode() {\n  var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var fromCharset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'UTF-8';\n  var encodedBytesCount = (str.match(/=[\\da-fA-F]{2}/g) || []).length;\n  var buffer = new Uint8Array(str.length - encodedBytesCount * 2);\n\n  for (var i = 0, len = str.length, bufferPos = 0; i < len; i++) {\n    var hex = str.substr(i + 1, 2);\n    var chr = str.charAt(i);\n\n    if (chr === '=' && hex && /[\\da-fA-F]{2}/.test(hex)) {\n      buffer[bufferPos++] = parseInt(hex, 16);\n      i += 2;\n    } else {\n      buffer[bufferPos++] = chr.charCodeAt(0);\n    }\n  }\n\n  return (0, _charset.decode)(buffer, fromCharset);\n}\n/**\n * Encodes a string or an typed array of given charset into unicode\n * base64 string. Also adds line breaks\n *\n * @param {String|Uint8Array} data String or typed array to be base64 encoded\n * @param {String} Initial charset, e.g. 'binary'. Defaults to 'UTF-8'\n * @return {String} Base64 encoded string\n */\n\n\nfunction base64Encode(data) {\n  var fromCharset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'UTF-8';\n  var buf = typeof data !== 'string' && fromCharset === 'binary' ? data : (0, _charset.convert)(data, fromCharset);\n  var b64 = (0, _emailjsBase.encode)(buf);\n  return _addBase64SoftLinebreaks(b64);\n}\n/**\n * Decodes a base64 string of any charset into an unicode string\n *\n * @param {String} str Base64 encoded string\n * @param {String} [fromCharset='UTF-8'] Original charset of the base64 encoded string\n * @return {String} Decoded unicode string\n */\n\n\nfunction base64Decode(str, fromCharset) {\n  var buf = (0, _emailjsBase.decode)(str, _emailjsBase.OUTPUT_TYPED_ARRAY);\n  return fromCharset === 'binary' ? (0, _charset.arr2str)(buf) : (0, _charset.decode)(buf, fromCharset);\n}\n/**\n * Encodes a string or an Uint8Array into a quoted printable encoding\n * This is almost the same as mimeEncode, except line breaks will be changed\n * as well to ensure that the lines are never longer than allowed length\n *\n * @param {String|Uint8Array} data String or an Uint8Array to mime encode\n * @param {String} [fromCharset='UTF-8'] Original charset of the string\n * @return {String} Mime encoded string\n */\n\n\nfunction quotedPrintableEncode() {\n  var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var fromCharset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'UTF-8';\n  var mimeEncodedStr = mimeEncode(data, fromCharset).replace(/\\r?\\n|\\r/g, '\\r\\n') // fix line breaks, ensure <CR><LF>\n  .replace(/[\\t ]+$/gm, function (spaces) {\n    return spaces.replace(/ /g, '=20').replace(/\\t/g, '=09');\n  }); // replace spaces in the end of lines\n\n  return _addQPSoftLinebreaks(mimeEncodedStr); // add soft line breaks to ensure line lengths sjorter than 76 bytes\n}\n/**\n * Decodes a string from a quoted printable encoding. This is almost the\n * same as mimeDecode, except line breaks will be changed as well\n *\n * @param {String} str Mime encoded string to decode\n * @param {String} [fromCharset='UTF-8'] Original charset of the string\n * @return {String} Mime decoded string\n */\n\n\nfunction quotedPrintableDecode() {\n  var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var fromCharset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'UTF-8';\n  var rawString = str.replace(/[\\t ]+$/gm, '') // remove invalid whitespace from the end of lines\n  .replace(/=(?:\\r?\\n|$)/g, ''); // remove soft line breaks\n\n  return mimeDecode(rawString, fromCharset);\n}\n/**\n * Encodes a string or an Uint8Array to an UTF-8 MIME Word\n *   https://tools.ietf.org/html/rfc2047\n *\n * @param {String|Uint8Array} data String to be encoded\n * @param {String} mimeWordEncoding='Q' Encoding for the mime word, either Q or B\n * @param {String} [fromCharset='UTF-8'] Source sharacter set\n * @return {String} Single or several mime words joined together\n */\n\n\nfunction mimeWordEncode(data) {\n  var mimeWordEncoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Q';\n  var fromCharset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'UTF-8';\n  var parts = [];\n  var str = typeof data === 'string' ? data : (0, _charset.decode)(data, fromCharset);\n\n  if (mimeWordEncoding === 'Q') {\n    var _str = typeof data === 'string' ? data : (0, _charset.decode)(data, fromCharset);\n\n    var encodedStr = (0, _ramda.pipe)(mimeEncode, qEncodeForbiddenHeaderChars)(_str);\n    parts = encodedStr.length < MAX_MIME_WORD_LENGTH ? [encodedStr] : _splitMimeEncodedString(encodedStr, MAX_MIME_WORD_LENGTH);\n  } else {\n    // Fits as much as possible into every line without breaking utf-8 multibyte characters' octets up across lines\n    var j = 0;\n    var i = 0;\n\n    while (i < str.length) {\n      if ((0, _charset.encode)(str.substring(j, i)).length > MAX_B64_MIME_WORD_BYTE_LENGTH) {\n        // we went one character too far, substring at the char before\n        parts.push(str.substring(j, i - 1));\n        j = i - 1;\n      } else {\n        i++;\n      }\n    } // add the remainder of the string\n\n\n    str.substring(j) && parts.push(str.substring(j));\n    parts = parts.map(_charset.encode).map(_emailjsBase.encode);\n  }\n\n  var prefix = '=?UTF-8?' + mimeWordEncoding + '?';\n  var suffix = '?= ';\n  return parts.map(function (p) {\n    return prefix + p + suffix;\n  }).join('').trim();\n}\n/**\n * Q-Encodes remaining forbidden header chars\n *   https://tools.ietf.org/html/rfc2047#section-5\n */\n\n\nvar qEncodeForbiddenHeaderChars = function qEncodeForbiddenHeaderChars(str) {\n  var qEncode = function qEncode(chr) {\n    return chr === ' ' ? '_' : '=' + (chr.charCodeAt(0) < 0x10 ? '0' : '') + chr.charCodeAt(0).toString(16).toUpperCase();\n  };\n\n  return str.replace(/[^a-z0-9!*+\\-/=]/ig, qEncode);\n};\n/**\n * Finds word sequences with non ascii text and converts these to mime words\n *\n * @param {String|Uint8Array} data String to be encoded\n * @param {String} mimeWordEncoding='Q' Encoding for the mime word, either Q or B\n * @param {String} [fromCharset='UTF-8'] Source sharacter set\n * @return {String} String with possible mime words\n */\n\n\nfunction mimeWordsEncode() {\n  var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var mimeWordEncoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Q';\n  var fromCharset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'UTF-8';\n  var regex = /([^\\s\\u0080-\\uFFFF]*[\\u0080-\\uFFFF]+[^\\s\\u0080-\\uFFFF]*(?:\\s+[^\\s\\u0080-\\uFFFF]*[\\u0080-\\uFFFF]+[^\\s\\u0080-\\uFFFF]*\\s*)?)+(?=\\s|$)/g;\n  return (0, _charset.decode)((0, _charset.convert)(data, fromCharset)).replace(regex, function (match) {\n    return match.length ? mimeWordEncode(match, mimeWordEncoding, fromCharset) : '';\n  });\n}\n/**\n * Decode a complete mime word encoded string\n *\n * @param {String} str Mime word encoded string\n * @return {String} Decoded unicode string\n */\n\n\nfunction mimeWordDecode() {\n  var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var match = str.match(/^=\\?([\\w_\\-*]+)\\?([QqBb])\\?([^?]*)\\?=$/i);\n  if (!match) return str; // RFC2231 added language tag to the encoding\n  // see: https://tools.ietf.org/html/rfc2231#section-5\n  // this implementation silently ignores this tag\n\n  var fromCharset = match[1].split('*').shift();\n  var encoding = (match[2] || 'Q').toString().toUpperCase();\n  var rawString = (match[3] || '').replace(/_/g, ' ');\n\n  if (encoding === 'B') {\n    return base64Decode(rawString, fromCharset);\n  } else if (encoding === 'Q') {\n    return mimeDecode(rawString, fromCharset);\n  } else {\n    return str;\n  }\n}\n/**\n * Decode a string that might include one or several mime words\n *\n * @param {String} str String including some mime words that will be encoded\n * @return {String} Decoded unicode string\n */\n\n\nfunction mimeWordsDecode() {\n  var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  str = str.toString().replace(/(=\\?[^?]+\\?[QqBb]\\?[^?]+\\?=)\\s+(?==\\?[^?]+\\?[QqBb]\\?[^?]*\\?=)/g, '$1'); // join bytes of multi-byte UTF-8\n\n  var prevEncoding = void 0;\n  str = str.replace(/(\\?=)?=\\?[uU][tT][fF]-8\\?([QqBb])\\?/g, function (match, endOfPrevWord, encoding) {\n    var result = endOfPrevWord && encoding === prevEncoding ? '' : match;\n    prevEncoding = encoding;\n    return result;\n  });\n  str = str.replace(/=\\?[\\w_\\-*]+\\?[QqBb]\\?[^?]*\\?=/g, function (mimeWord) {\n    return mimeWordDecode(mimeWord.replace(/\\s+/g, ''));\n  });\n  return str;\n}\n/**\n * Folds long lines, useful for folding header lines (afterSpace=false) and\n * flowed text (afterSpace=true)\n *\n * @param {String} str String to be folded\n * @param {Boolean} afterSpace If true, leave a space in th end of a line\n * @return {String} String with folded lines\n */\n\n\nfunction foldLines() {\n  var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var afterSpace = arguments[1];\n  var pos = 0;\n  var len = str.length;\n  var result = '';\n  var line = void 0,\n      match = void 0;\n\n  while (pos < len) {\n    line = str.substr(pos, MAX_LINE_LENGTH);\n\n    if (line.length < MAX_LINE_LENGTH) {\n      result += line;\n      break;\n    }\n\n    if (match = line.match(/^[^\\n\\r]*(\\r?\\n|\\r)/)) {\n      line = match[0];\n      result += line;\n      pos += line.length;\n      continue;\n    } else if ((match = line.match(/(\\s+)[^\\s]*$/)) && match[0].length - (afterSpace ? (match[1] || '').length : 0) < line.length) {\n      line = line.substr(0, line.length - (match[0].length - (afterSpace ? (match[1] || '').length : 0)));\n    } else if (match = str.substr(pos + line.length).match(/^[^\\s]+(\\s*)/)) {\n      line = line + match[0].substr(0, match[0].length - (!afterSpace ? (match[1] || '').length : 0));\n    }\n\n    result += line;\n    pos += line.length;\n\n    if (pos < len) {\n      result += '\\r\\n';\n    }\n  }\n\n  return result;\n}\n/**\n * Encodes and folds a header line for a MIME message header.\n * Shorthand for mimeWordsEncode + foldLines\n *\n * @param {String} key Key name, will not be encoded\n * @param {String|Uint8Array} value Value to be encoded\n * @param {String} [fromCharset='UTF-8'] Character set of the value\n * @return {String} encoded and folded header line\n */\n\n\nfunction headerLineEncode(key, value, fromCharset) {\n  var encodedValue = mimeWordsEncode(value, 'Q', fromCharset);\n  return foldLines(key + ': ' + encodedValue);\n}\n/**\n * The result is not mime word decoded, you need to do your own decoding based\n * on the rules for the specific header key\n *\n * @param {String} headerLine Single header line, might include linebreaks as well if folded\n * @return {Object} And object of {key, value}\n */\n\n\nfunction headerLineDecode() {\n  var headerLine = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var line = headerLine.toString().replace(/(?:\\r?\\n|\\r)[ \\t]*/g, ' ').trim();\n  var match = line.match(/^\\s*([^:]+):(.*)$/);\n  return {\n    key: (match && match[1] || '').trim(),\n    value: (match && match[2] || '').trim()\n  };\n}\n/**\n * Parses a block of header lines. Does not decode mime words as every\n * header might have its own rules (eg. formatted email addresses and such)\n *\n * @param {String} headers Headers string\n * @return {Object} An object of headers, where header keys are object keys. NB! Several values with the same key make up an Array\n */\n\n\nfunction headerLinesDecode(headers) {\n  var lines = headers.split(/\\r?\\n|\\r/);\n  var headersObj = {};\n\n  for (var i = lines.length - 1; i >= 0; i--) {\n    if (i && lines[i].match(/^\\s/)) {\n      lines[i - 1] += '\\r\\n' + lines[i];\n      lines.splice(i, 1);\n    }\n  }\n\n  for (var _i = 0, len = lines.length; _i < len; _i++) {\n    var header = headerLineDecode(lines[_i]);\n    var key = header.key.toLowerCase();\n    var value = header.value;\n\n    if (!headersObj[key]) {\n      headersObj[key] = value;\n    } else {\n      headersObj[key] = [].concat(headersObj[key], value);\n    }\n  }\n\n  return headersObj;\n}\n/**\n * Parses a header value with key=value arguments into a structured\n * object.\n *\n *   parseHeaderValue('content-type: text/plain; CHARSET='UTF-8'') ->\n *   {\n *     'value': 'text/plain',\n *     'params': {\n *       'charset': 'UTF-8'\n *     }\n *   }\n *\n * @param {String} str Header value\n * @return {Object} Header value as a parsed structure\n */\n\n\nfunction parseHeaderValue(str) {\n  var response = {\n    value: false,\n    params: {}\n  };\n  var key = false;\n  var value = '';\n  var type = 'value';\n  var quote = false;\n  var escaped = false;\n  var chr = void 0;\n\n  for (var i = 0, len = str.length; i < len; i++) {\n    chr = str.charAt(i);\n\n    if (type === 'key') {\n      if (chr === '=') {\n        key = value.trim().toLowerCase();\n        type = 'value';\n        value = '';\n        continue;\n      }\n\n      value += chr;\n    } else {\n      if (escaped) {\n        value += chr;\n      } else if (chr === '\\\\') {\n        escaped = true;\n        continue;\n      } else if (quote && chr === quote) {\n        quote = false;\n      } else if (!quote && chr === '\"') {\n        quote = chr;\n      } else if (!quote && chr === ';') {\n        if (key === false) {\n          response.value = value.trim();\n        } else {\n          response.params[key] = value.trim();\n        }\n\n        type = 'key';\n        value = '';\n      } else {\n        value += chr;\n      }\n\n      escaped = false;\n    }\n  }\n\n  if (type === 'value') {\n    if (key === false) {\n      response.value = value.trim();\n    } else {\n      response.params[key] = value.trim();\n    }\n  } else if (value.trim()) {\n    response.params[value.trim().toLowerCase()] = '';\n  } // handle parameter value continuations\n  // https://tools.ietf.org/html/rfc2231#section-3\n  // preprocess values\n\n\n  Object.keys(response.params).forEach(function (key) {\n    var actualKey, nr, match, value;\n\n    if (match = key.match(/(\\*(\\d+)|\\*(\\d+)\\*|\\*)$/)) {\n      actualKey = key.substr(0, match.index);\n      nr = Number(match[2] || match[3]) || 0;\n\n      if (!response.params[actualKey] || _typeof(response.params[actualKey]) !== 'object') {\n        response.params[actualKey] = {\n          charset: false,\n          values: []\n        };\n      }\n\n      value = response.params[key];\n\n      if (nr === 0 && match[0].substr(-1) === '*' && (match = value.match(/^([^']*)'[^']*'(.*)$/))) {\n        response.params[actualKey].charset = match[1] || 'iso-8859-1';\n        value = match[2];\n      }\n\n      response.params[actualKey].values[nr] = value; // remove the old reference\n\n      delete response.params[key];\n    }\n  }); // concatenate split rfc2231 strings and convert encoded strings to mime encoded words\n\n  Object.keys(response.params).forEach(function (key) {\n    var value;\n\n    if (response.params[key] && Array.isArray(response.params[key].values)) {\n      value = response.params[key].values.map(function (val) {\n        return val || '';\n      }).join('');\n\n      if (response.params[key].charset) {\n        // convert \"%AB\" to \"=?charset?Q?=AB?=\"\n        response.params[key] = '=?' + response.params[key].charset + '?Q?' + value.replace(/[=?_\\s]/g, function (s) {\n          // fix invalidly encoded chars\n          var c = s.charCodeAt(0).toString(16);\n          return s === ' ' ? '_' : '%' + (c.length < 2 ? '0' : '') + c;\n        }).replace(/%/g, '=') + '?='; // change from urlencoding to percent encoding\n      } else {\n        response.params[key] = value;\n      }\n    }\n  });\n  return response;\n}\n/**\n * Encodes a string or an Uint8Array to an UTF-8 Parameter Value Continuation encoding (rfc2231)\n * Useful for splitting long parameter values.\n *\n * For example\n *      title=\"unicode string\"\n * becomes\n *     title*0*=\"utf-8''unicode\"\n *     title*1*=\"%20string\"\n *\n * @param {String|Uint8Array} data String to be encoded\n * @param {Number} [maxLength=50] Max length for generated chunks\n * @param {String} [fromCharset='UTF-8'] Source sharacter set\n * @return {Array} A list of encoded keys and headers\n */\n\n\nfunction continuationEncode(key, data, maxLength, fromCharset) {\n  var list = [];\n  var encodedStr = typeof data === 'string' ? data : (0, _charset.decode)(data, fromCharset);\n  var line;\n  maxLength = maxLength || 50; // process ascii only text\n\n  if (/^[\\w.\\- ]*$/.test(data)) {\n    // check if conversion is even needed\n    if (encodedStr.length <= maxLength) {\n      return [{\n        key: key,\n        value: /[\\s\";=]/.test(encodedStr) ? '\"' + encodedStr + '\"' : encodedStr\n      }];\n    }\n\n    encodedStr = encodedStr.replace(new RegExp('.{' + maxLength + '}', 'g'), function (str) {\n      list.push({\n        line: str\n      });\n      return '';\n    });\n\n    if (encodedStr) {\n      list.push({\n        line: encodedStr\n      });\n    }\n  } else {\n    // process text with unicode or special chars\n    var uriEncoded = encodeURIComponent('utf-8\\'\\'' + encodedStr);\n    var i = 0;\n\n    while (true) {\n      var len = maxLength; // must not split hex encoded byte between lines\n\n      if (uriEncoded[i + maxLength - 1] === '%') {\n        len -= 1;\n      } else if (uriEncoded[i + maxLength - 2] === '%') {\n        len -= 2;\n      }\n\n      line = uriEncoded.substr(i, len);\n\n      if (!line) {\n        break;\n      }\n\n      list.push({\n        line: line,\n        encoded: true\n      });\n      i += line.length;\n    }\n  }\n\n  return list.map(function (item, i) {\n    return {\n      // encoded lines: {name}*{part}*\n      // unencoded lines: {name}*{part}\n      // if any line needs to be encoded then the first line (part==0) is always encoded\n      key: key + '*' + i + (item.encoded ? '*' : ''),\n      value: /[\\s\";=]/.test(item.line) ? '\"' + item.line + '\"' : item.line\n    };\n  });\n}\n/**\n * Splits a mime encoded string. Needed for dividing mime words into smaller chunks\n *\n * @param {String} str Mime encoded string to be split up\n * @param {Number} maxlen Maximum length of characters for one part (minimum 12)\n * @return {Array} Split string\n */\n\n\nfunction _splitMimeEncodedString(str) {\n  var maxlen = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 12;\n  var minWordLength = 12; // require at least 12 symbols to fit possible 4 octet UTF-8 sequences\n\n  var maxWordLength = Math.max(maxlen, minWordLength);\n  var lines = [];\n\n  while (str.length) {\n    var curLine = str.substr(0, maxWordLength);\n    var match = curLine.match(/=[0-9A-F]?$/i); // skip incomplete escaped char\n\n    if (match) {\n      curLine = curLine.substr(0, match.index);\n    }\n\n    var done = false;\n\n    while (!done) {\n      var chr = void 0;\n      done = true;\n\n      var _match = str.substr(curLine.length).match(/^=([0-9A-F]{2})/i); // check if not middle of a unicode char sequence\n\n\n      if (_match) {\n        chr = parseInt(_match[1], 16); // invalid sequence, move one char back anc recheck\n\n        if (chr < 0xC2 && chr > 0x7F) {\n          curLine = curLine.substr(0, curLine.length - 3);\n          done = false;\n        }\n      }\n    }\n\n    if (curLine.length) {\n      lines.push(curLine);\n    }\n\n    str = str.substr(curLine.length);\n  }\n\n  return lines;\n}\n\nfunction _addBase64SoftLinebreaks() {\n  var base64EncodedStr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  return base64EncodedStr.trim().replace(new RegExp('.{' + MAX_LINE_LENGTH + '}', 'g'), '$&\\r\\n').trim();\n}\n/**\n * Adds soft line breaks(the ones that will be stripped out when decoding QP)\n *\n * @param {String} qpEncodedStr String in Quoted-Printable encoding\n * @return {String} String with forced line breaks\n */\n\n\nfunction _addQPSoftLinebreaks() {\n  var qpEncodedStr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var pos = 0;\n  var len = qpEncodedStr.length;\n  var lineMargin = Math.floor(MAX_LINE_LENGTH / 3);\n  var result = '';\n  var match = void 0,\n      line = void 0; // insert soft linebreaks where needed\n\n  while (pos < len) {\n    line = qpEncodedStr.substr(pos, MAX_LINE_LENGTH);\n\n    if (match = line.match(/\\r\\n/)) {\n      line = line.substr(0, match.index + match[0].length);\n      result += line;\n      pos += line.length;\n      continue;\n    }\n\n    if (line.substr(-1) === '\\n') {\n      // nothing to change here\n      result += line;\n      pos += line.length;\n      continue;\n    } else if (match = line.substr(-lineMargin).match(/\\n.*?$/)) {\n      // truncate to nearest line break\n      line = line.substr(0, line.length - (match[0].length - 1));\n      result += line;\n      pos += line.length;\n      continue;\n    } else if (line.length > MAX_LINE_LENGTH - lineMargin && (match = line.substr(-lineMargin).match(/[ \\t.,!?][^ \\t.,!?]*$/))) {\n      // truncate to nearest space\n      line = line.substr(0, line.length - (match[0].length - 1));\n    } else if (line.substr(-1) === '\\r') {\n      line = line.substr(0, line.length - 1);\n    } else {\n      if (line.match(/=[\\da-f]{0,2}$/i)) {\n        // push incomplete encoding sequences to the next line\n        if (match = line.match(/=[\\da-f]{0,1}$/i)) {\n          line = line.substr(0, line.length - match[0].length);\n        } // ensure that utf-8 sequences are not split\n\n\n        while (line.length > 3 && line.length < len - pos && !line.match(/^(?:=[\\da-f]{2}){1,4}$/i) && (match = line.match(/=[\\da-f]{2}$/ig))) {\n          var code = parseInt(match[0].substr(1, 2), 16);\n\n          if (code < 128) {\n            break;\n          }\n\n          line = line.substr(0, line.length - 3);\n\n          if (code >= 0xC0) {\n            break;\n          }\n        }\n      }\n    }\n\n    if (pos + line.length < len && line.substr(-1) !== '\\n') {\n      if (line.length === MAX_LINE_LENGTH && line.match(/=[\\da-f]{2}$/i)) {\n        line = line.substr(0, line.length - 3);\n      } else if (line.length === MAX_LINE_LENGTH) {\n        line = line.substr(0, line.length - 1);\n      }\n\n      pos += line.length;\n      line += '=\\r\\n';\n    } else {\n      pos += line.length;\n    }\n\n    result += line;\n  }\n\n  return result;\n}\n\nexports.decode = _charset.decode;\nexports.encode = _charset.encode;\nexports.convert = _charset.convert;","map":{"version":3,"mappings":"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","names":["mimeEncode","mimeDecode","base64Encode","base64Decode","quotedPrintableEncode","quotedPrintableDecode","mimeWordEncode","mimeWordsEncode","mimeWordDecode","mimeWordsDecode","foldLines","headerLineEncode","headerLineDecode","headerLinesDecode","parseHeaderValue","continuationEncode","MAX_LINE_LENGTH","MAX_MIME_WORD_LENGTH","MAX_B64_MIME_WORD_BYTE_LENGTH","data","fromCharset","buffer","reduce","aggregate","ord","index","_checkRanges","length","String","fromCharCode","toString","toUpperCase","nr","ranges","val","range","str","encodedBytesCount","match","Uint8Array","i","len","bufferPos","hex","substr","chr","charAt","test","parseInt","charCodeAt","buf","b64","_addBase64SoftLinebreaks","OUTPUT_TYPED_ARRAY","mimeEncodedStr","replace","spaces","_addQPSoftLinebreaks","rawString","mimeWordEncoding","parts","encodedStr","qEncodeForbiddenHeaderChars","_splitMimeEncodedString","j","substring","push","map","encode","encodeBase64","prefix","suffix","p","join","trim","qEncode","regex","split","shift","encoding","prevEncoding","endOfPrevWord","result","mimeWord","afterSpace","pos","line","key","value","encodedValue","headerLine","headers","lines","headersObj","splice","header","toLowerCase","concat","response","params","type","quote","escaped","Object","keys","forEach","actualKey","Number","_typeof","charset","values","Array","isArray","s","c","maxLength","list","RegExp","uriEncoded","encodeURIComponent","encoded","item","maxlen","minWordLength","maxWordLength","Math","max","curLine","done","base64EncodedStr","qpEncodedStr","lineMargin","floor","code","decode","convert"],"sources":["../src/mimecodec.js"],"sourcesContent":["import { encode as encodeBase64, decode as decodeBase64, OUTPUT_TYPED_ARRAY } from 'emailjs-base64'\nimport { encode, decode, convert, arr2str } from './charset'\nimport { pipe } from 'ramda'\n\n// Lines can't be longer than 76 + <CR><LF> = 78 bytes\n// http://tools.ietf.org/html/rfc2045#section-6.7\nconst MAX_LINE_LENGTH = 76\nconst MAX_MIME_WORD_LENGTH = 52\nconst MAX_B64_MIME_WORD_BYTE_LENGTH = 39\n\n/**\n * Encodes all non printable and non ascii bytes to =XX form, where XX is the\n * byte value in hex. This function does not convert linebreaks etc. it\n * only escapes character sequences\n *\n * @param {String|Uint8Array} data Either a string or an Uint8Array\n * @param {String} [fromCharset='UTF-8'] Source encoding\n * @return {String} Mime encoded string\n */\nexport function mimeEncode (data = '', fromCharset = 'UTF-8') {\n  const buffer = convert(data, fromCharset)\n  return buffer.reduce((aggregate, ord, index) =>\n    _checkRanges(ord) && !((ord === 0x20 || ord === 0x09) && (index === buffer.length - 1 || buffer[index + 1] === 0x0a || buffer[index + 1] === 0x0d))\n      ? aggregate + String.fromCharCode(ord) // if the char is in allowed range, then keep as is, unless it is a ws in the end of a line\n      : aggregate + '=' + (ord < 0x10 ? '0' : '') + ord.toString(16).toUpperCase(), '')\n\n  function _checkRanges (nr) {\n    const ranges = [ // https://tools.ietf.org/html/rfc2045#section-6.7\n      [0x09], // <TAB>\n      [0x0A], // <LF>\n      [0x0D], // <CR>\n      [0x20, 0x3C], // <SP>!\"#$%&'()*+,-./0123456789:;\n      [0x3E, 0x7E] // >?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}\n    ]\n    return ranges.reduce((val, range) => val || (range.length === 1 && nr === range[0]) || (range.length === 2 && nr >= range[0] && nr <= range[1]), false)\n  }\n}\n\n/**\n * Decodes mime encoded string to an unicode string\n *\n * @param {String} str Mime encoded string\n * @param {String} [fromCharset='UTF-8'] Source encoding\n * @return {String} Decoded unicode string\n */\nexport function mimeDecode (str = '', fromCharset = 'UTF-8') {\n  const encodedBytesCount = (str.match(/=[\\da-fA-F]{2}/g) || []).length\n  let buffer = new Uint8Array(str.length - encodedBytesCount * 2)\n\n  for (var i = 0, len = str.length, bufferPos = 0; i < len; i++) {\n    let hex = str.substr(i + 1, 2)\n    const chr = str.charAt(i)\n    if (chr === '=' && hex && /[\\da-fA-F]{2}/.test(hex)) {\n      buffer[bufferPos++] = parseInt(hex, 16)\n      i += 2\n    } else {\n      buffer[bufferPos++] = chr.charCodeAt(0)\n    }\n  }\n\n  return decode(buffer, fromCharset)\n}\n\n/**\n * Encodes a string or an typed array of given charset into unicode\n * base64 string. Also adds line breaks\n *\n * @param {String|Uint8Array} data String or typed array to be base64 encoded\n * @param {String} Initial charset, e.g. 'binary'. Defaults to 'UTF-8'\n * @return {String} Base64 encoded string\n */\nexport function base64Encode (data, fromCharset = 'UTF-8') {\n  const buf = (typeof data !== 'string' && fromCharset === 'binary') ? data : convert(data, fromCharset)\n  const b64 = encodeBase64(buf)\n  return _addBase64SoftLinebreaks(b64)\n}\n\n/**\n * Decodes a base64 string of any charset into an unicode string\n *\n * @param {String} str Base64 encoded string\n * @param {String} [fromCharset='UTF-8'] Original charset of the base64 encoded string\n * @return {String} Decoded unicode string\n */\nexport function base64Decode (str, fromCharset) {\n  const buf = decodeBase64(str, OUTPUT_TYPED_ARRAY)\n  return fromCharset === 'binary' ? arr2str(buf) : decode(buf, fromCharset)\n}\n\n/**\n * Encodes a string or an Uint8Array into a quoted printable encoding\n * This is almost the same as mimeEncode, except line breaks will be changed\n * as well to ensure that the lines are never longer than allowed length\n *\n * @param {String|Uint8Array} data String or an Uint8Array to mime encode\n * @param {String} [fromCharset='UTF-8'] Original charset of the string\n * @return {String} Mime encoded string\n */\nexport function quotedPrintableEncode (data = '', fromCharset = 'UTF-8') {\n  const mimeEncodedStr = mimeEncode(data, fromCharset)\n    .replace(/\\r?\\n|\\r/g, '\\r\\n') // fix line breaks, ensure <CR><LF>\n    .replace(/[\\t ]+$/gm, spaces => spaces.replace(/ /g, '=20').replace(/\\t/g, '=09')) // replace spaces in the end of lines\n\n  return _addQPSoftLinebreaks(mimeEncodedStr) // add soft line breaks to ensure line lengths sjorter than 76 bytes\n}\n\n/**\n * Decodes a string from a quoted printable encoding. This is almost the\n * same as mimeDecode, except line breaks will be changed as well\n *\n * @param {String} str Mime encoded string to decode\n * @param {String} [fromCharset='UTF-8'] Original charset of the string\n * @return {String} Mime decoded string\n */\nexport function quotedPrintableDecode (str = '', fromCharset = 'UTF-8') {\n  const rawString = str\n    .replace(/[\\t ]+$/gm, '') // remove invalid whitespace from the end of lines\n    .replace(/=(?:\\r?\\n|$)/g, '') // remove soft line breaks\n\n  return mimeDecode(rawString, fromCharset)\n}\n\n/**\n * Encodes a string or an Uint8Array to an UTF-8 MIME Word\n *   https://tools.ietf.org/html/rfc2047\n *\n * @param {String|Uint8Array} data String to be encoded\n * @param {String} mimeWordEncoding='Q' Encoding for the mime word, either Q or B\n * @param {String} [fromCharset='UTF-8'] Source sharacter set\n * @return {String} Single or several mime words joined together\n */\nexport function mimeWordEncode (data, mimeWordEncoding = 'Q', fromCharset = 'UTF-8') {\n  let parts = []\n  const str = (typeof data === 'string') ? data : decode(data, fromCharset)\n\n  if (mimeWordEncoding === 'Q') {\n    const str = (typeof data === 'string') ? data : decode(data, fromCharset)\n    let encodedStr = pipe(mimeEncode, qEncodeForbiddenHeaderChars)(str)\n    parts = encodedStr.length < MAX_MIME_WORD_LENGTH ? [encodedStr] : _splitMimeEncodedString(encodedStr, MAX_MIME_WORD_LENGTH)\n  } else {\n    // Fits as much as possible into every line without breaking utf-8 multibyte characters' octets up across lines\n    let j = 0\n    let i = 0\n    while (i < str.length) {\n      if (encode(str.substring(j, i)).length > MAX_B64_MIME_WORD_BYTE_LENGTH) {\n        // we went one character too far, substring at the char before\n        parts.push(str.substring(j, i - 1))\n        j = i - 1\n      } else {\n        i++\n      }\n    }\n    // add the remainder of the string\n    str.substring(j) && parts.push(str.substring(j))\n    parts = parts.map(encode).map(encodeBase64)\n  }\n\n  const prefix = '=?UTF-8?' + mimeWordEncoding + '?'\n  const suffix = '?= '\n  return parts.map(p => prefix + p + suffix).join('').trim()\n}\n\n/**\n * Q-Encodes remaining forbidden header chars\n *   https://tools.ietf.org/html/rfc2047#section-5\n */\nconst qEncodeForbiddenHeaderChars = function (str) {\n  const qEncode = chr => chr === ' ' ? '_' : ('=' + (chr.charCodeAt(0) < 0x10 ? '0' : '') + chr.charCodeAt(0).toString(16).toUpperCase())\n  return str.replace(/[^a-z0-9!*+\\-/=]/ig, qEncode)\n}\n\n/**\n * Finds word sequences with non ascii text and converts these to mime words\n *\n * @param {String|Uint8Array} data String to be encoded\n * @param {String} mimeWordEncoding='Q' Encoding for the mime word, either Q or B\n * @param {String} [fromCharset='UTF-8'] Source sharacter set\n * @return {String} String with possible mime words\n */\nexport function mimeWordsEncode (data = '', mimeWordEncoding = 'Q', fromCharset = 'UTF-8') {\n  const regex = /([^\\s\\u0080-\\uFFFF]*[\\u0080-\\uFFFF]+[^\\s\\u0080-\\uFFFF]*(?:\\s+[^\\s\\u0080-\\uFFFF]*[\\u0080-\\uFFFF]+[^\\s\\u0080-\\uFFFF]*\\s*)?)+(?=\\s|$)/g\n  return decode(convert(data, fromCharset)).replace(regex, match => match.length ? mimeWordEncode(match, mimeWordEncoding, fromCharset) : '')\n}\n\n/**\n * Decode a complete mime word encoded string\n *\n * @param {String} str Mime word encoded string\n * @return {String} Decoded unicode string\n */\nexport function mimeWordDecode (str = '') {\n  const match = str.match(/^=\\?([\\w_\\-*]+)\\?([QqBb])\\?([^?]*)\\?=$/i)\n  if (!match) return str\n\n  // RFC2231 added language tag to the encoding\n  // see: https://tools.ietf.org/html/rfc2231#section-5\n  // this implementation silently ignores this tag\n  const fromCharset = match[1].split('*').shift()\n  const encoding = (match[2] || 'Q').toString().toUpperCase()\n  const rawString = (match[3] || '').replace(/_/g, ' ')\n\n  if (encoding === 'B') {\n    return base64Decode(rawString, fromCharset)\n  } else if (encoding === 'Q') {\n    return mimeDecode(rawString, fromCharset)\n  } else {\n    return str\n  }\n}\n\n/**\n * Decode a string that might include one or several mime words\n *\n * @param {String} str String including some mime words that will be encoded\n * @return {String} Decoded unicode string\n */\nexport function mimeWordsDecode (str = '') {\n  str = str.toString().replace(/(=\\?[^?]+\\?[QqBb]\\?[^?]+\\?=)\\s+(?==\\?[^?]+\\?[QqBb]\\?[^?]*\\?=)/g, '$1')\n  // join bytes of multi-byte UTF-8\n  let prevEncoding\n  str = str.replace(/(\\?=)?=\\?[uU][tT][fF]-8\\?([QqBb])\\?/g, (match, endOfPrevWord, encoding) => {\n    const result = (endOfPrevWord && encoding === prevEncoding) ? '' : match\n    prevEncoding = encoding\n    return result\n  })\n  str = str.replace(/=\\?[\\w_\\-*]+\\?[QqBb]\\?[^?]*\\?=/g, mimeWord => mimeWordDecode(mimeWord.replace(/\\s+/g, '')))\n\n  return str\n}\n\n/**\n * Folds long lines, useful for folding header lines (afterSpace=false) and\n * flowed text (afterSpace=true)\n *\n * @param {String} str String to be folded\n * @param {Boolean} afterSpace If true, leave a space in th end of a line\n * @return {String} String with folded lines\n */\nexport function foldLines (str = '', afterSpace) {\n  let pos = 0\n  const len = str.length\n  let result = ''\n  let line, match\n\n  while (pos < len) {\n    line = str.substr(pos, MAX_LINE_LENGTH)\n    if (line.length < MAX_LINE_LENGTH) {\n      result += line\n      break\n    }\n    if ((match = line.match(/^[^\\n\\r]*(\\r?\\n|\\r)/))) {\n      line = match[0]\n      result += line\n      pos += line.length\n      continue\n    } else if ((match = line.match(/(\\s+)[^\\s]*$/)) && match[0].length - (afterSpace ? (match[1] || '').length : 0) < line.length) {\n      line = line.substr(0, line.length - (match[0].length - (afterSpace ? (match[1] || '').length : 0)))\n    } else if ((match = str.substr(pos + line.length).match(/^[^\\s]+(\\s*)/))) {\n      line = line + match[0].substr(0, match[0].length - (!afterSpace ? (match[1] || '').length : 0))\n    }\n\n    result += line\n    pos += line.length\n    if (pos < len) {\n      result += '\\r\\n'\n    }\n  }\n\n  return result\n}\n\n/**\n * Encodes and folds a header line for a MIME message header.\n * Shorthand for mimeWordsEncode + foldLines\n *\n * @param {String} key Key name, will not be encoded\n * @param {String|Uint8Array} value Value to be encoded\n * @param {String} [fromCharset='UTF-8'] Character set of the value\n * @return {String} encoded and folded header line\n */\nexport function headerLineEncode (key, value, fromCharset) {\n  var encodedValue = mimeWordsEncode(value, 'Q', fromCharset)\n  return foldLines(key + ': ' + encodedValue)\n}\n\n/**\n * The result is not mime word decoded, you need to do your own decoding based\n * on the rules for the specific header key\n *\n * @param {String} headerLine Single header line, might include linebreaks as well if folded\n * @return {Object} And object of {key, value}\n */\nexport function headerLineDecode (headerLine = '') {\n  const line = headerLine.toString().replace(/(?:\\r?\\n|\\r)[ \\t]*/g, ' ').trim()\n  const match = line.match(/^\\s*([^:]+):(.*)$/)\n\n  return {\n    key: ((match && match[1]) || '').trim(),\n    value: ((match && match[2]) || '').trim()\n  }\n}\n\n/**\n * Parses a block of header lines. Does not decode mime words as every\n * header might have its own rules (eg. formatted email addresses and such)\n *\n * @param {String} headers Headers string\n * @return {Object} An object of headers, where header keys are object keys. NB! Several values with the same key make up an Array\n */\nexport function headerLinesDecode (headers) {\n  const lines = headers.split(/\\r?\\n|\\r/)\n  const headersObj = {}\n\n  for (let i = lines.length - 1; i >= 0; i--) {\n    if (i && lines[i].match(/^\\s/)) {\n      lines[i - 1] += '\\r\\n' + lines[i]\n      lines.splice(i, 1)\n    }\n  }\n\n  for (let i = 0, len = lines.length; i < len; i++) {\n    const header = headerLineDecode(lines[i])\n    const key = header.key.toLowerCase()\n    const value = header.value\n\n    if (!headersObj[key]) {\n      headersObj[key] = value\n    } else {\n      headersObj[key] = [].concat(headersObj[key], value)\n    }\n  }\n\n  return headersObj\n}\n\n/**\n * Parses a header value with key=value arguments into a structured\n * object.\n *\n *   parseHeaderValue('content-type: text/plain; CHARSET='UTF-8'') ->\n *   {\n *     'value': 'text/plain',\n *     'params': {\n *       'charset': 'UTF-8'\n *     }\n *   }\n *\n * @param {String} str Header value\n * @return {Object} Header value as a parsed structure\n */\nexport function parseHeaderValue (str) {\n  let response = {\n    value: false,\n    params: {}\n  }\n  let key = false\n  let value = ''\n  let type = 'value'\n  let quote = false\n  let escaped = false\n  let chr\n\n  for (let i = 0, len = str.length; i < len; i++) {\n    chr = str.charAt(i)\n    if (type === 'key') {\n      if (chr === '=') {\n        key = value.trim().toLowerCase()\n        type = 'value'\n        value = ''\n        continue\n      }\n      value += chr\n    } else {\n      if (escaped) {\n        value += chr\n      } else if (chr === '\\\\') {\n        escaped = true\n        continue\n      } else if (quote && chr === quote) {\n        quote = false\n      } else if (!quote && chr === '\"') {\n        quote = chr\n      } else if (!quote && chr === ';') {\n        if (key === false) {\n          response.value = value.trim()\n        } else {\n          response.params[key] = value.trim()\n        }\n        type = 'key'\n        value = ''\n      } else {\n        value += chr\n      }\n      escaped = false\n    }\n  }\n\n  if (type === 'value') {\n    if (key === false) {\n      response.value = value.trim()\n    } else {\n      response.params[key] = value.trim()\n    }\n  } else if (value.trim()) {\n    response.params[value.trim().toLowerCase()] = ''\n  }\n\n  // handle parameter value continuations\n  // https://tools.ietf.org/html/rfc2231#section-3\n\n  // preprocess values\n  Object.keys(response.params).forEach(function (key) {\n    var actualKey, nr, match, value\n    if ((match = key.match(/(\\*(\\d+)|\\*(\\d+)\\*|\\*)$/))) {\n      actualKey = key.substr(0, match.index)\n      nr = Number(match[2] || match[3]) || 0\n\n      if (!response.params[actualKey] || typeof response.params[actualKey] !== 'object') {\n        response.params[actualKey] = {\n          charset: false,\n          values: []\n        }\n      }\n\n      value = response.params[key]\n\n      if (nr === 0 && match[0].substr(-1) === '*' && (match = value.match(/^([^']*)'[^']*'(.*)$/))) {\n        response.params[actualKey].charset = match[1] || 'iso-8859-1'\n        value = match[2]\n      }\n\n      response.params[actualKey].values[nr] = value\n\n      // remove the old reference\n      delete response.params[key]\n    }\n  })\n\n  // concatenate split rfc2231 strings and convert encoded strings to mime encoded words\n  Object.keys(response.params).forEach(function (key) {\n    var value\n    if (response.params[key] && Array.isArray(response.params[key].values)) {\n      value = response.params[key].values.map(function (val) {\n        return val || ''\n      }).join('')\n\n      if (response.params[key].charset) {\n        // convert \"%AB\" to \"=?charset?Q?=AB?=\"\n        response.params[key] = '=?' + response.params[key].charset + '?Q?' + value\n          .replace(/[=?_\\s]/g, function (s) {\n            // fix invalidly encoded chars\n            var c = s.charCodeAt(0).toString(16)\n            return s === ' ' ? '_' : '%' + (c.length < 2 ? '0' : '') + c\n          })\n          .replace(/%/g, '=') + '?=' // change from urlencoding to percent encoding\n      } else {\n        response.params[key] = value\n      }\n    }\n  })\n\n  return response\n}\n\n/**\n * Encodes a string or an Uint8Array to an UTF-8 Parameter Value Continuation encoding (rfc2231)\n * Useful for splitting long parameter values.\n *\n * For example\n *      title=\"unicode string\"\n * becomes\n *     title*0*=\"utf-8''unicode\"\n *     title*1*=\"%20string\"\n *\n * @param {String|Uint8Array} data String to be encoded\n * @param {Number} [maxLength=50] Max length for generated chunks\n * @param {String} [fromCharset='UTF-8'] Source sharacter set\n * @return {Array} A list of encoded keys and headers\n */\nexport function continuationEncode (key, data, maxLength, fromCharset) {\n  const list = []\n  var encodedStr = typeof data === 'string' ? data : decode(data, fromCharset)\n  var line\n\n  maxLength = maxLength || 50\n\n  // process ascii only text\n  if (/^[\\w.\\- ]*$/.test(data)) {\n    // check if conversion is even needed\n    if (encodedStr.length <= maxLength) {\n      return [{\n        key: key,\n        value: /[\\s\";=]/.test(encodedStr) ? '\"' + encodedStr + '\"' : encodedStr\n      }]\n    }\n\n    encodedStr = encodedStr.replace(new RegExp('.{' + maxLength + '}', 'g'), function (str) {\n      list.push({\n        line: str\n      })\n      return ''\n    })\n\n    if (encodedStr) {\n      list.push({\n        line: encodedStr\n      })\n    }\n  } else {\n    // process text with unicode or special chars\n    const uriEncoded = encodeURIComponent('utf-8\\'\\'' + encodedStr)\n    let i = 0\n    while (true) {\n      let len = maxLength\n      // must not split hex encoded byte between lines\n      if (uriEncoded[i + maxLength - 1] === '%') {\n        len -= 1\n      } else if (uriEncoded[i + maxLength - 2] === '%') {\n        len -= 2\n      }\n      line = uriEncoded.substr(i, len)\n      if (!line) {\n        break\n      }\n      list.push({\n        line: line,\n        encoded: true\n      })\n      i += line.length\n    }\n  }\n\n  return list.map(function (item, i) {\n    return {\n      // encoded lines: {name}*{part}*\n      // unencoded lines: {name}*{part}\n      // if any line needs to be encoded then the first line (part==0) is always encoded\n      key: key + '*' + i + (item.encoded ? '*' : ''),\n      value: /[\\s\";=]/.test(item.line) ? '\"' + item.line + '\"' : item.line\n    }\n  })\n}\n\n/**\n * Splits a mime encoded string. Needed for dividing mime words into smaller chunks\n *\n * @param {String} str Mime encoded string to be split up\n * @param {Number} maxlen Maximum length of characters for one part (minimum 12)\n * @return {Array} Split string\n */\nfunction _splitMimeEncodedString (str, maxlen = 12) {\n  const minWordLength = 12 // require at least 12 symbols to fit possible 4 octet UTF-8 sequences\n  const maxWordLength = Math.max(maxlen, minWordLength)\n  const lines = []\n\n  while (str.length) {\n    let curLine = str.substr(0, maxWordLength)\n\n    const match = curLine.match(/=[0-9A-F]?$/i) // skip incomplete escaped char\n    if (match) {\n      curLine = curLine.substr(0, match.index)\n    }\n\n    let done = false\n    while (!done) {\n      let chr\n      done = true\n      const match = str.substr(curLine.length).match(/^=([0-9A-F]{2})/i) // check if not middle of a unicode char sequence\n      if (match) {\n        chr = parseInt(match[1], 16)\n        // invalid sequence, move one char back anc recheck\n        if (chr < 0xC2 && chr > 0x7F) {\n          curLine = curLine.substr(0, curLine.length - 3)\n          done = false\n        }\n      }\n    }\n\n    if (curLine.length) {\n      lines.push(curLine)\n    }\n    str = str.substr(curLine.length)\n  }\n\n  return lines\n}\n\nfunction _addBase64SoftLinebreaks (base64EncodedStr = '') {\n  return base64EncodedStr.trim().replace(new RegExp('.{' + MAX_LINE_LENGTH + '}', 'g'), '$&\\r\\n').trim()\n}\n\n/**\n * Adds soft line breaks(the ones that will be stripped out when decoding QP)\n *\n * @param {String} qpEncodedStr String in Quoted-Printable encoding\n * @return {String} String with forced line breaks\n */\nfunction _addQPSoftLinebreaks (qpEncodedStr = '') {\n  let pos = 0\n  const len = qpEncodedStr.length\n  const lineMargin = Math.floor(MAX_LINE_LENGTH / 3)\n  let result = ''\n  let match, line\n\n  // insert soft linebreaks where needed\n  while (pos < len) {\n    line = qpEncodedStr.substr(pos, MAX_LINE_LENGTH)\n    if ((match = line.match(/\\r\\n/))) {\n      line = line.substr(0, match.index + match[0].length)\n      result += line\n      pos += line.length\n      continue\n    }\n\n    if (line.substr(-1) === '\\n') {\n      // nothing to change here\n      result += line\n      pos += line.length\n      continue\n    } else if ((match = line.substr(-lineMargin).match(/\\n.*?$/))) {\n      // truncate to nearest line break\n      line = line.substr(0, line.length - (match[0].length - 1))\n      result += line\n      pos += line.length\n      continue\n    } else if (line.length > MAX_LINE_LENGTH - lineMargin && (match = line.substr(-lineMargin).match(/[ \\t.,!?][^ \\t.,!?]*$/))) {\n      // truncate to nearest space\n      line = line.substr(0, line.length - (match[0].length - 1))\n    } else if (line.substr(-1) === '\\r') {\n      line = line.substr(0, line.length - 1)\n    } else {\n      if (line.match(/=[\\da-f]{0,2}$/i)) {\n        // push incomplete encoding sequences to the next line\n        if ((match = line.match(/=[\\da-f]{0,1}$/i))) {\n          line = line.substr(0, line.length - match[0].length)\n        }\n\n        // ensure that utf-8 sequences are not split\n        while (line.length > 3 && line.length < len - pos && !line.match(/^(?:=[\\da-f]{2}){1,4}$/i) && (match = line.match(/=[\\da-f]{2}$/ig))) {\n          const code = parseInt(match[0].substr(1, 2), 16)\n          if (code < 128) {\n            break\n          }\n\n          line = line.substr(0, line.length - 3)\n\n          if (code >= 0xC0) {\n            break\n          }\n        }\n      }\n    }\n\n    if (pos + line.length < len && line.substr(-1) !== '\\n') {\n      if (line.length === MAX_LINE_LENGTH && line.match(/=[\\da-f]{2}$/i)) {\n        line = line.substr(0, line.length - 3)\n      } else if (line.length === MAX_LINE_LENGTH) {\n        line = line.substr(0, line.length - 1)\n      }\n      pos += line.length\n      line += '=\\r\\n'\n    } else {\n      pos += line.length\n    }\n\n    result += line\n  }\n\n  return result\n}\n\nexport { decode, encode, convert }\n"]},"metadata":{},"sourceType":"script"}